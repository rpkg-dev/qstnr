---
editor_options:
  chunk_output_type: console
---

# NOTES

## qstnr format

-   While the qstnr format is supposed to be written in the TOML file format, its schemas are written in the [JSON Schema](https://json-schema.org/) format.

    qstnr validates its TOML files using `pal::toml_validate()` which relies on the external [Taplo CLI](https://taplo.tamasfe.dev/cli/introduction.html)[\^2],
    which is available as a standalone binary for all common platforms [from here](https://github.com/tamasfe/taplo/releases/latest). Taplo allows to define the
    schema to be used directly in the TOML file using the [`schema` header
    directive](https://taplo.tamasfe.dev/configuration/directives.html#the-schema-directive).

## qstnr terminology

qstnr specification

:   Entirety of all qstnr specification parts.

qstnr specification part

:   One of `r cli::ansi_collapse(pal::wrap_chr(all_spec_parts, "`"), last =" or ")\` defining the respective qstnr elements. A part must adhere to its
    respective schema.

qstnr survey configuration

:   Definition of a concrete survey instance using the qstnr framework. This includes all relevant qstnr specification part sources as well as the (grouped)
    qstnr item identifiers in the desired order. Must adhere to the `survey` schema.

## LimeSurvey R clients

Relevant R packages:

-   [LimeRick](https://github.com/kalimu/LimeRick) (abandoned since 2017)
-   [limer](https://github.com/cloudyr/limer) (abandoned since 2018)
-   [**limonaid**](https://r-packages.gitlab.io/limonaid/) (partially based on the work of the limer developer)

## Further information

### Survey design best practices

-   [*Questionnaire Design Tip Sheet* by Harvard University Program on Survey Research](https://psr.iq.harvard.edu/book/questionnaire-design-tip-sheet)
-   [*Writing Survey Questions* by Pew Research Center](https://www.pewresearch.org/our-methods/u-s-surveys/writing-survey-questions/)
-   [*How to design a good survey (guide)* in the LimeSurvey Manual](https://manual.limesurvey.org/How_to_design_a_good_survey_(guide))
-   [*Survey design tips & tricks* by LimeSurvey Consulting](https://limesurvey-consulting.com/survey-design-tips-tricks/)

# INTERNAL

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 ":=",
                                 # tidyselect fns
                                 "all_of",
                                 "any_of",
                                 "matches",
                                 "starts_with",
                                 # other
                                 "description",
                                 "group_id",
                                 "id",
                                 "int",
                                 "init_config",
                                 "lang",
                                 "name",
                                 "path",
                                 "question",
                                 "question_block",
                                 "question_block_filled",
                                 "targets",
                                 "title",
                                 "value_order",
                                 "value_scale",
                                 "value_set_id",
                                 "value_sets",
                                 "values",
                                 "values_targets"))
```

## Package load/unload

```{r}
.onLoad <- function(libname, pkgname) {
  
  # clear pkgpins cache
  tryCatch(expr = pkgpins::clear_cache(board = pkgpins::board(pkg = pkgname,
                                                              pkg_versioned = FALSE),
                                       max_age = pal::pkg_config_val(key = "max_cache_lifespan",
                                                                     pkg = pkgname)),
           error = function(e) cli::cli_alert_warning(text = "Failed to clear pkgpins cache on load of {.pkg pkgname}. Error message: {e$message}"))
}
```

## Constants

```{r}
this_pkg <- utils::packageName()
```

### `all_spec_parts`

In the order they should be processed.

```{r}
all_spec_parts <- c("links",
                    "footnotes",
                    "value_sets",
                    "targets",
                    "question_blocks",
                    "items")
```

### `struct_survey`

TODO:

-   Figure out whether it's feasible to generate the key hierarchy tree(s) directly from the JSON schemas (cue: "JSON schema visualization") and only add
    specification schemes for the remaining parts.

    So far:

    -   [~~tidyjson~~](https://cran.r-project.org/web/packages/tidyjson/vignettes/visualizing-json.html) *Not about JSON Schemas, but rather regular JSON!*
    -   [JSON Schema Viewer](https://github.com/jlblcc/json-schema-viewer) (umaintained since 2017)

NOTES:

-   Pretty-print using:

    ``` r
    struct_survey |>
      pal::flatten_path_tree() |>
      purrr::map_chr(cli::format_inline) |>
      pal::draw_path_tree()
    ```

-   Use `cli::ansi_strip()` after `pal::flatten_path_tree()` to remove the cli formatting.

```{r}
struct_source <- list("[[{.strong source}]]" = list("{.strong list},{.strong file},{.strong url} = {.emph EXPR},{.emph PATH},{.emph URL}"))

struct_survey <- list("{.strong qstnr}" = list(
  "{.strong items}" = c(struct_source,
                        list("[[{.strong group}]]" = list("id = {.strong {'<questionnaire_block>'}}",
                                                          "item_ids = [ {.emph id_1}, {.emph id_2}, {.emph ...} ]"))),
  "{.strong question_blocks}" = struct_source,
  "{.strong value_sets}" = struct_source,
  "{.strong targets}" = struct_source,
  "{.strong footnotes}" = struct_source,
  "{.strong links}" = struct_source
))

rm(struct_source)
```

## Functions

### `assert_qstnr_tibble`

```{r}
assert_qstnr_tibble <- function(qstnr,
                                cols = character()) {
  
  checkmate::assert_data_frame(qstnr,
                               all.missing = FALSE,
                               min.rows = 1L)
  missing_cols <- setdiff(cols,
                          colnames(qstnr))
  if (length(missing_cols) > 0L) {
    cli::cli_abort("Mandatory columns {.var {missing_cols}} are missing from {.arg qstnr}.")
  }
}
```

### `assert_survey_config`

```{r}
assert_survey_config <- function(survey_config,
                                 els = character()) {
  
  checkmate::assert_list(survey_config,
                         all.missing = FALSE)
  missing_els <- setdiff(els,
                         names(survey_config))
  if (length(missing_els) > 0L) {
    cli::cli_abort("Mandatory elements {.var {missing_els}} are missing from {.arg survey_config}.")
  }
}
```

### `combine_spec_part_srcs`

NOTES:

-   Currently, only source types `file` and `url` get validated since validation is based on JSON schemas.

```{r}
combine_spec_part_srcs <- function(srcs,
                                   spec_part,
                                   dir,
                                   validate) {
  result <- list()
  
  for (i in seq_along(srcs)) {
    
    src_type <- names(srcs[[i]])
    src_content <- switch(EXPR = src_type,
                          "expr" = spec_part_expr(expr = srcs[[i]]$expr),
                          "file" = spec_part_file(file = srcs[[i]]$file,
                                                  dir = dir,
                                                  spec_part = spec_part,
                                                  validate = validate),
                          "url"  = spec_part_url(url = srcs[[i]]$url,
                                                 spec_part = spec_part,
                                                 validate = validate))
    result %<>% purrr::list_modify(!!!src_content)
  }
  
  result
}
```

### `emph_md`

Properly handles multiline strings and possibly existing emphasis (in simple cases; inline code etc. is not considered).

```{r}
emph_md <- function(x,
                    emph = "*") {
  
  x %>%
    purrr::map_chr(\(x) {
      
      x %>%
        stringr::str_split(pattern = "\n") %>%
        purrr::map(\(x2) {
          x2 %>%
            stringr::str_replace_all(pattern = paste0(stringr::str_escape(emph), "(.*)", stringr::str_escape(emph)),
                                     replacement = "\\1") %>%
            stringr::str_replace_all(pattern = "^(.)",
                                     replacement = paste0(emph, "\\1")) %>%
            stringr::str_replace_all(pattern = "(.)$",
                                     replacement = paste0("\\1", emph))
        }) %>%
        purrr::list_c(ptype = character()) %>%
        stringr::str_flatten(collapse = "\n")
    })
}
```

### `gen_qstnr_row`

```{r}
gen_qstnr_row <- function(.item,
                          ...) {
  
  result <- tibble::tibble(.rows = 1L)
  
  for (key in setdiff(item_keys$key, "i")) {
    
    val <- .item[[key]]
    is_list_col <- !item_keys$is_scalar[item_keys$key == key] || item_keys$has_lang_subkeys[item_keys$key == key]
    
    if (is.null(val)) {
      
      # assign explicit default val if present
      if (item_keys$has_default[item_keys$key == key]) {
        val <- unlist(item_keys$default_val[item_keys$key == key],
                      recursive = FALSE)
        
        # assign NA of proper type if non-list col
      } else if (!is_list_col) {
        val <- unlist(item_keys$default_val[item_keys$key == key],
                      recursive = FALSE)[NA]
      }
      # perform possible string interpolation
    } else if (item_keys$type[item_keys$key == key] == "character") {
      
      val %<>% purrr::modify_tree(leaf = \(x1) purrr::map_chr(x1, \(x2) interpolate(x2, ...)),
                                  is_node = is.list)
    }
    
    if (is_list_col) {
      val %<>% list()
    }
    
    result %<>% tibble::add_column(!!key := val)
  }
  
  result
}
```

### `gen_qstnr_rows`

Recursively iterates over all the item iterators.

```{r}
gen_qstnr_rows <- function(item,
                           i = 1L,
                           i_list = list()) {
  
  if (i < length(item$i)) {
    
    result <-
      purrr::map(item$i[[i]],
                 \(cur_i) {
                   
                   i_list %<>% c(rlang::list2("i{i}" := cur_i))
                   
                   gen_qstnr_rows(item = item,
                                  i = i + 1L,
                                  i_list = i_list)
                 }) %>%
      purrr::list_rbind()
    
  } else {
    
    result <-
      purrr::map(item$i[[i]],
                 \(cur_i) {
                   
                   i_list %<>% c(rlang::list2("i{i}" := cur_i))
                   
                   gen_qstnr_row(.item = item,
                                 !!!i_list)
                   
                 }) %>%
      purrr::list_rbind()
  }
  
  result
}
```

### `interpolate`

```{r}
interpolate <- function(.x,
                        ...) {

  # assign objects in dots to current env ensuring `cli::pluralize()` finds them
  rlang::env_bind(.env = rlang::current_env(),
                  ...)
  
  cli::pluralize(.x,
                 .null = NA_character_,
                 .trim = FALSE)
}
```

### `order_qstnr_cols`

```{r}
order_qstnr_cols <- function(qstnr) {
  
  qstnr %>% dplyr::relocate(any_of(qstnr_cols))
}
```

### `rm_p`

```{r}
rm_p <- function(x) {
  
  stringr::str_replace(string = x,
                       pattern = "^<p>(.*)</p>(\n)?$",
                       replacement = "\\1")
}
```

### `schema_url`

```{r}
schema_url <- function(spec_part,
                       dev = TRUE) {
  
  glue::glue("https://qstnr.rpkg.dev/", ifelse(dev, "dev/", ""), "schemas/qstnr-{spec_part}.schema.json")
}
```

### `spec_part_expr`

```{r}
spec_part_expr <- function(expr) {
  
  eval(expr = parse(text = expr),
       # eval in empty env to avoid unintended results
       envir = emptyenv()) %>%
    checkmate::assert_list(any.missing = FALSE)
}
```

### `spec_part_file`

```{r}
spec_part_file <- function(file,
                           dir,
                           spec_part,
                           validate) {
  
  path <- fs::path(dir, file)
  
  if (is.null(validate) || validate) {
    toml_validate(input = path,
                  from_file = TRUE,
                  spec_part = spec_part,
                  use_cache = is.null(validate))
  }
  
  pal::toml_read(input = path,
                 from_file = TRUE)
}
```

### `spec_part_url`

NOTES:

-   Use `url = "https://qstnr.rpkg.dev/dev/configs/default/items.toml"` to test.

```{r}
spec_part_url <- function(url,
                          spec_part,
                          validate) {
  toml_content <-
    httr::RETRY(verb = "GET",
              url = url) %>%
    httr::content(as = "text", encoding = "UTF-8")
  
  if (is.null(validate) || validate) {
    toml_validate(input = toml_content,
                  from_file = FALSE,
                  spec_part = spec_part,
                  use_cache = is.null(validate))
  }
  
  pal::toml_read(input = toml_content,
                 from_file = FALSE)
}
```

### `toml_validate`

```{r}
toml_validate <- function(input,
                          from_file,
                          spec_part,
                          use_cache = TRUE) {
  
  hash <- if (from_file) rlang::hash_file(path = input) else rlang::hash(input)
  
  # cache validation based on TOML (file) content hash
  pkgpins::with_cache(expr = pal::toml_validate(input = input,
                                                from_file = from_file,
                                                schema = schema_url(spec_part = spec_part)),
                      pkg = this_pkg,
                      from_fn = "toml_validate",
                      from_file,
                      hash,
                      pkg_versioned = FALSE,
                      use_cache = use_cache,
                      cache_lifespan = Inf)
}
```

# EXPORTED

## Survey preparation

### DESCRIPTION

Functions to process raw survey configurations.

### `read_survey_config`

```{r}
#' Read in survey config
#'
#' Assembles a raw TOML survey configuration into a combined survey configuration list.
#'
#' @param path Path to the survey config TOML file. A character scalar.
#' @param validate Whether or not to validate all input TOML files, i.e. ensure that they adhere to their respective schemas. Validation usually adds a
#'   noticeable delay. If `NULL`, validation is performed only for files whose content has changed since the last successful validation.
#'
#' @return A list containing the combined survey configuration.
#' @family survey_prep
#' @export
read_survey_config <- function(path,
                               validate = NULL) {
  
  checkmate::assert_flag(validate,
                         null.ok = TRUE)
  
  if (is.null(validate) || validate) {
    toml_validate(input = path,
                  from_file = TRUE,
                  spec_part = "survey",
                  use_cache = is.null(validate))
  }
  
  dir <- fs::path_dir(path) %>% fs::path_abs()
  survey_config_raw <- pal::toml_read(input = path)
  spec_parts <-
    names(survey_config_raw$qstnr) %>%
    intersect(all_spec_parts) %>%
    pal::order_by(by = all_spec_parts) %>%
    rlang::set_names() %>%
    purrr::map(~ {
      combine_spec_part_srcs(srcs = survey_config_raw$qstnr[[.x]]$source,
                             spec_part = .x,
                             dir = dir,
                             validate = validate)
    })
  # validity check: ensure no value set has the reserved name/ID `values`
  if (any(names(spec_parts$value_sets) == "values")) {
    
    cli::cli_abort("Value set with reserved name {.val values} detected in value set specification.")
  }
  if (spec_parts$value_sets |>
      purrr::map_chr(\(x) purrr::chuck(x, "id")) |> 
      magrittr::equals("values") |>
      any()) {
    
    cli::cli_abort("Value set with reserved {.var id} {.val values} detected in value set specification.")
  }
  # keep only items that are actually needed
  spec_parts$items %<>% purrr::keep_at(at = unlist(purrr::map_depth(.x = survey_config_raw$qstnr$items$group,
                                                                    .depth = 1L,
                                                                    .f = \(x) x$item_ids)))
  # extract non-spec-part stuff
  other <- survey_config_raw$qstnr %>% purrr::keep_at(at = setdiff(survey_config_keys,
                                                                   all_spec_parts))
  # create final list struct
  rlang::list2(item_groups = survey_config_raw$qstnr$items$group,
               !!!spec_parts,
               !!!other)
}
```

### `htmlize_survey_config`

```{r}
#' Convert survey config from Markdown to HTML
#'
#' Recursively converts the keys at the specified pluck locations of a survey configuration from Markdown to HTML using [commonmark::markdown_html()]. Keys to
#' be converted must be of (nested) type character.
#'
#' @inheritParams gen_qstnr
#' @inheritParams commonmark::markdown_html
#' @param ... [Pluck][purrr::pluck] locations to convert to HTML. All (sub)keys targeted here must be of type character.
#'   `r pkgsnip::param_lbl("dyn_dots_support")`
#' @param rm_p Whether or not to omit the outer `<p>` tag when converting values to HTML.
#'
#' @return `survey_config` with the specified keys recursively converted to HTML text.
#' @family survey_prep
#' @export
htmlize_survey_config <- function(survey_config,
                                  ...,
                                  rm_p = FALSE,
                                  hardbreaks = FALSE,
                                  smart = TRUE,
                                  normalize = TRUE,
                                  extensions = c("table", "strikethrough", "tasklist")) {
  
  assert_survey_config(survey_config = survey_config)
  
  for (pl in rlang::list2(...)) {
    
    survey_config %<>% purrr::modify_in(.where = pl,
                                        .f = \(x) purrr::modify_tree(x,
                                                                     is_node = is.list,
                                                                     leaf = \(x2) {
                                                                       
                                                                       if (length(2) > 0L) {
                                                                         
                                                                         if (!checkmate::test_character(x2)) {
                                                                           cli::cli_abort(paste0("Key {.var {key}} at pluck location {.code {deparse(pl)}} is ",
                                                                                                 "not of (nested) type character."))
                                                                         }
                                                                         
                                                                         x2 %<>% purrr::map_chr(\(x3) commonmark::markdown_html(text = x3,
                                                                                                                               hardbreaks = hardbreaks,
                                                                                                                               smart = smart,
                                                                                                                               normalize = normalize,
                                                                                                                               extensions = extensions))
                                                                         if (rm_p) x2 %<>% rm_p()
                                                                       }
                                                                       
                                                                       x2
                                                                     }))
  }
  
  survey_config
}
```

## Questionnaire generation

### DESCRIPTION

Functions to generate different representations of a questionnaire from a combined survey configuration.

### `gen_qstnr`

```{r}
#' Generate questionnaire tibble
#'
#' @param survey_config Survey configuration list as returned by [read_survey_config()].
#'
#' @return `r pkgsnip::return_label("data")`
#' @family qstnr_gen
#' @export
gen_qstnr <- function(survey_config) {
  
  assert_survey_config(survey_config = survey_config,
                       els = c("items", "item_groups"))
  result <-
    survey_config$item_groups %>%
    rlang::set_names(nm = purrr::map_depth(., 1L, \(x) x$id)) %>%
    # for each item group
    purrr::map(
      # for each item ID
      \(group) {
        purrr::map(
          group$item_ids,
          \(id) {
            
            item <- survey_config$items[[id]]
            
            # integrity check
            if (is.null(item)) {
              cli::cli_abort("Item with {.var id} {.val {id}} is listed in survey configuration but missing from survey items specifications.")
            }
            
            if (length(item[["i"]]) > 0L) {
              return(gen_qstnr_rows(item = item))
            } else {
              return(gen_qstnr_row(.item = item))
            }
          }) %>%
          purrr::list_rbind()
      }) %>%
    purrr::list_rbind(names_to = "group_id") %>%
    # add overall item numbering
    tibble::rowid_to_column(var = "order") %>%
    # replace `value_sets` with actual `values` and add complemented value sets as `values` subkey `value_set_id`
    dplyr::group_by(id) %>%
    dplyr::group_modify(\(d, k) {
      
      # combine all (int and ext) value sets
      d_new <-
        unlist(d$value_sets) |>
        purrr::map(\(value_set_id) {
          
          # handle internal value set
          if (value_set_id == "values") {
            
            result <-
              d$values |>
              dplyr::first() |>
              tibble::as_tibble() |>
              tibble::add_column(value_set_id = "values",
                                 value_scale = d$value_scale) |>
              dplyr::mutate(int = as.integer(int))
            
            # handle external value sets
          } else {
            
            val_set <- val_set(id = value_set_id,
                               survey_config = survey_config)
            result <-
              val_set$values |>
              tibble::as_tibble() |>
              tibble::add_column(value_set_id = value_set_id,
                                 value_scale = val_set$value_scale)
          }
          
          result
        }) |>
        purrr::list_rbind()
      
      # complement with default `values.targets`
      if (!("targets" %in% colnames(d_new))) {
        d_new$targets <- "all"
      }
      
      # add common value scale to top level
      d$value_scale <- purrr::reduce(unique(d_new$value_scale),
                                     common_val_scale)
      # harmonize col order and wrap whole tibble in list
      d_new %<>%
        dplyr::relocate(colnames(.) |> stringr::str_subset("^\\w{2}$") |> sort(),
                        int, targets, value_scale, value_set_id) %>%
        list()
      
      d$values <- d_new
      d
    }) |>
    dplyr::ungroup() |>
    dplyr::select(-value_sets) |>
    # reduce to English `title` and `description` only for now
    dplyr::mutate(title = purrr::map_chr(title, \(x) x$en),
                  description = purrr::map_chr(description, \(x) x$en)) |>
    # restore original item order
    dplyr::arrange(order) |>
    # harmonize col order
    order_qstnr_cols()
  
  # warn if item and item group IDs overlap
  ids_overlap <- intersect(result$group_id,
                           result$id)
  
  if (length(ids_overlap) > 0L) {
    cli::cli_warn("Item group identifiers and item identifiers must be overall unique for further processing. Overlapping IDs include {.val {ids_overlap}}.")
  }
  
  result
}
```

### `unnest_qstnr`

NOTES:

-   We have to unnest the `values` col separately from the `question` col since they can have different lengths.

```{r}
#' Unnest questionnaire tibble
#'
#' Unnests a nested qstnr tibble as returned by [gen_qstnr()] into one row per question `lang` and `id`.
#'
#' @param qstnr Nested questionnaire tibble as returned by [gen_qstnr()].
#'
#' @return `r pkgsnip::return_label("data")`
#' @family qstnr_gen
#' @export
unnest_qstnr <- function(qstnr) {
  
  assert_qstnr_tibble(qstnr = qstnr,
                      cols = c("order", "id", "question_block", "question", "values"))
  qstnr %>%
    dplyr::group_by(id) %>%
    dplyr::group_modify(\(d, k) {
      
      lang_specific_subset <-
        d %>%
        dplyr::select(question) %>%
        # unnest `question` lang-subkeys
        tidyr::unnest_longer(col = question,
                             indices_to = "lang",
                             keep_empty = TRUE,
                             simplify = FALSE)
      
      d$values_int <- list(d$values[[1L]]$int)
      d$values_targets <- list(d$values[[1L]]$targets)
      d$values_scale <- list(d$values[[1L]]$value_scale)
      d$values_set_id <- list(d$values[[1L]]$value_set_id)
      d$values <- list(d$values[[1L]] %>% purrr::keep_at(at = nchar(names(.)) == 2L))
      
      lang_specific_subset_2 <-
        d$values |>
        dplyr::first() |>
        purrr::imap(\(col, lang) tibble::tibble(lang = lang,
                                                values = list(col))) |>
        purrr::list_rbind()
      
      # NOTE: items can have no `values` and thus `lang_specific_subset_2` no rows
      if (nrow(lang_specific_subset_2)) {
        
        lang_specific_subset %<>% dplyr::full_join(y = lang_specific_subset_2,
                                                   by = "lang")
      }
        
      d %>%
        dplyr::select(-c(question, values)) %>%
        dplyr::cross_join(y = lang_specific_subset)
    }) %>%
    dplyr::ungroup() %>%
    # restore row order
    dplyr::arrange(order) %>%
    # harmonize col order
    order_qstnr_cols()
}
```

### `unnest_qstnr_vals`

```{r}
#' Unnest questionnaire tibble's item values
#'
#' @description
#' Unnests a semi-unnested qstnr tibble as returned by [unnest_qstnr()] into one row per question `lang`, `id` and `value`.
#' 
#' The columns `r val_cols <- qstnr_cols |> stringr::str_subset("^values"); val_cols |> pal::prose_ls(wrap = "\x60")` will thereby become
#' `r val_cols |> stringr::str_replace("^values", "value") |> pal::prose_ls(wrap = "\x60")`. Additionally, a column `value_order` is added holding the intended
#' value order as defined in the questionnaire.
#'
#' @param qstnr Semi-unnested questionnaire tibble as returned by [gen_qstnr()].
#'
#' @return `r pkgsnip::return_label("data")`
#' @family qstnr_gen
#' @export
unnest_qstnr_vals <- function(qstnr) {
  
  assert_qstnr_tibble(qstnr = qstnr,
                      cols = c("order", "lang", "id", "values", "values_int"))
  qstnr |>
    # complement `values` with `values_int`
    dplyr::group_by(id, lang) |>
    dplyr::group_modify(\(d, k) {
      
      if (is.null(d$values[[1L]])) {
        d$values <- purrr::map(d$values_int,
                               \(x) as.character(x))
      }
      
      d
    }) |>
    dplyr::ungroup() |>
    # harmonize `values_targets` struct
    dplyr::mutate(dplyr::across(any_of("values_targets"),
                                \(x) purrr::map(x,
                                                \(x2) {
                                                if (purrr::pluck_depth(x2) < 2L) {
                                                  x2 %<>% as.list()
                                                }
                                                x2
                                              }))) |>
    # unnest `values*` cols
    tidyr::unnest_longer(col = starts_with("values"),
                         indices_to = "{col}_order") |>
    ## remove top-level `value_scale` col in favor of per-value `values_scale`
    dplyr::select(-any_of("value_scale")) |>
    dplyr::rename_with(.cols = starts_with("values"),
                       .fn = \(x) stringr::str_replace(string = x,
                                                       pattern = "^values",
                                                       replacement = "value")) |>
    # remove surplus `value_*_order` cols
    dplyr::select(-matches("^value_.+_order$")) |>
    # unnest `question` col if present
    tidyr::unnest_longer(col = any_of("question"),
                         keep_empty = TRUE) |>
    # restore row order
    dplyr::arrange(order,
                   lang,
                   value_order) |>
    # harmonize col order
    order_qstnr_cols()
}
```

### `htmlize_qstnr`

```{r}
#' Convert qstnr columns from Markdown to HTML
#'
#' Recursively converts the specified columns from Markdown to HTML using [commonmark::markdown_html()]. Columns to be converted must be of (nested) type
#' character.
#'
#' @inheritParams unnest_qstnr_vals
#' @inheritParams commonmark::markdown_html
#' @param cols Column names to convert to HTML. All columns must be of type character. Mustn't overlap with `cols_rm_p`.
#'   `r pkgsnip::param_lbl("tidy_select_support")`
#' @param cols_rm_p Columns names to convert to HTML *without the outer `<p>` tag*. All columns must be of type character. Mustn't overlap with `cols`.
#'   `r pkgsnip::param_lbl("tidy_select_support")`
#'
#' @return `qstnr` with values in `cols` converted to HTML text.
#' @family qstnr_gen
#' @export
htmlize_qstnr <- function(qstnr,
                          cols = c("title", "description", "question"),
                          cols_rm_p = "values",
                          hardbreaks = FALSE,
                          smart = TRUE,
                          normalize = TRUE,
                          extensions = c("table", "strikethrough", "tasklist")) {
  
  assert_qstnr_tibble(qstnr = qstnr)
  
  # tidy selection
  defused_cols <- rlang::enquo(cols)
  defused_cols_rm_p <- rlang::enquo(cols_rm_p)
  ix_cols <- tidyselect::eval_select(expr = defused_cols,
                                     data = qstnr)
  ix_cols_rm_p <- tidyselect::eval_select(expr = defused_cols_rm_p,
                                          data = qstnr)
  names_cols <- names(ix_cols)
  names_cols_rm_p <- names(ix_cols_rm_p)
  overlaps <- intersect(names_cols, names_cols_rm_p)
  
  if (length(overlaps) > 0L) {
    cli::cli_abort("Overlapping column specifications between {.arg cols} and {.arg cols_rm_p} detected: {.val overlaps}")
  }
  
  qstnr |> dplyr::mutate(dplyr::across(.cols = all_of(c(names_cols, names_cols_rm_p)),
                                       .fns = \(x) {
                                         
                                         cur_col <- dplyr::cur_column()
                                         do_rm_p <- cur_col %in% names_cols_rm_p
                                         
                                         x %<>% purrr::modify_tree(is_node = is.list,
                                                                   leaf = \(x2) {
                                                                     
                                                                     if (length(x2) > 0L) {
                                                                       
                                                                       if (!checkmate::test_character(x2)) {
                                                                         cli::cli_abort(paste0("Column {.var {cur_col}} specified in {.arg {ifelse(do_rm_p, ",
                                                                                               "'cols_rm_p', 'cols')}} is not of (nested) type character."))
                                                                       }
                                                                       
                                                                       x2 %<>% purrr::map_chr(\(x3) commonmark::markdown_html(text = x3,
                                                                                                                              hardbreaks = hardbreaks,
                                                                                                                              smart = smart,
                                                                                                                              normalize = normalize,
                                                                                                                              extensions = extensions))
                                                                       if (do_rm_p) x2 %<>% rm_p()
                                                                     }
                                                                     
                                                                     x2
                                                                   })
                                       }))
}
```

### `gen_qmd_qstnr`

```{r}
#' Generate Quarto Markdown questionnaire
#'
#' @inheritParams gen_qstnr
#' @param qstnr Unnested questionnaire tibble as returned by [unnest_qstnr()].
#' @param lang Language in which to output the questionnaire. A character scalar.
#' @param path Path to write the generated questionnaire file to. A character scalar.
#' @param add_item_ids Whether or not to add questionnaire item identifiers next to the question texts.
#'
#' @return `qstnr`, invisibly.
#' @family qstnr_gen
#' @export
gen_qmd_qstnr <- function(qstnr,
                          survey_config,
                          lang,
                          path,
                          add_item_ids = TRUE) {
  
  assert_qstnr_tibble(qstnr = qstnr,
                      cols = c("lang", "group_id", "id", "question_block", "question", "values", "is_mandatory", "allow_multiple_answers"))
  assert_survey_config(survey_config = survey_config,
                       els = c("question_blocks", "title", "intro", "outro"))
  rlang::arg_match0(arg = lang,
                    values = unique(qstnr$lang))
  checkmate::assert_path_for_output(path,
                                    overwrite = TRUE)
  checkmate::assert_flag(add_item_ids)
  
  notice_mandatory <- c(pal::wrap_chr(survey_config$notice$mandatory[[lang]] %||%
                                        notice$mandatory[[lang]] %||%
                                        notice$mandatory$en,
                                      wrap = "*"),
                        "")
  notice_multiple_answers <- c(pal::wrap_chr(survey_config$notice$multiple_answers[[lang]] %||%
                                               notice$multiple_answers[[lang]] %||%
                                               notice$multiple_answers$en,
                                             wrap = "*"),
                               "")
  survey_blocks <-
    qstnr |>
    dplyr::filter(lang == !!lang) |>
    # fill missing `question_block`s with `id`s to avoid order mess up further below
    dplyr::mutate(question_block_filled = dplyr::if_else(is.na(question_block),
                                                         id,
                                                         question_block),
                  # note that we need to rely on factors to avoid alphabetical group key ordering further below
                  dplyr::across(c(group_id, question_block_filled, id),
                                \(x) factor(x,
                                            levels = unique(x)))) |>
    dplyr::group_by(group_id) |>
    dplyr::group_map(\(d1, k1) {
      
      question_blocks <-
        d1 |>
        dplyr::group_by(question_block_filled) |>
        dplyr::group_map(\(d2, k2) {
          
          is_question_block <- length(unique(d2$id)) > 1L
          is_question_block_compact <- is_question_block && length(unique(d2$values)) == 1L
          
          questions <-
            d2 |>
            dplyr::group_by(id) |>
            dplyr::group_map(\(d3, k3) {
              
              q_text <- emph_md(unlist(d3$question),
                                emph = "**")
              q_id <- paste0("^`", k3$id, "`^")
              
              # layout is conditional on whether the question is part of a block or not
              if (!is_question_block) {
                question <- c(paste0(q_text, "  "[add_item_ids]),
                              q_id[add_item_ids],
                              "",
                              paste0("- ", unlist(d3$values)),
                              "",
                              notice_mandatory[d3$is_mandatory],
                              notice_multiple_answers[d3$allow_multiple_answers])
              } else {
                question <- c(paste0("- ", q_text, " ", q_id[add_item_ids]))
                
                if (!is_question_block_compact) {
                  question %<>% c(paste0("  - ", unlist(d3$values)))
                }
              }
              
              question
            }) |>
            purrr::list_c(ptype = character())
          
          c(survey_config$question_blocks[[as.character(k2$question_block_filled)]]$intro[[lang]][is_question_block],
            ""[is_question_block],
            questions,
            ""[is_question_block_compact],
            paste0("Es kann jeweils mit ", pal::prose_ls(unlist(d2$values[1L]), last_sep = " oder ", wrap = '"'),
                   " geantwortet werden.")[is_question_block_compact],
            ""[is_question_block],
            notice_mandatory[is_question_block && d2$is_mandatory[1L]],
            notice_multiple_answers[is_question_block && d2$allow_multiple_answers[1L]])
        }) |>
        purrr::list_c(ptype = character())
      
      pretty_group <-
        k1$group_id |>
        stringr::str_replace_all("_", " ") |>
        stringr::str_to_title() |>
        emph_md(emph = "**")
      
      c(paste0("## Block ", pretty_group),
        "",
        question_blocks,
        "",
        "{{< pagebreak >}}",
        "")
    }) |>
    purrr::list_c(ptype = character())
  
  c(paste0("# ", survey_config$title[[lang]]),
    "",
    survey_config$intro[[lang]],
    "",
    "{{< pagebreak >}}",
    "",
    survey_blocks,
    survey_config$outro[[lang]]) |>
    brio::write_lines(path = path)
}
```

## Auxiliary

### `as_int_vals`

TODO: Rethink and finish this.

```{r}
#' Convert question values to codes
#'
#' Converts character question values to their integer code counterparts. The latter are useful mainly because they're language-independent.
#'
#' @param var Variable holding the question values. A character vector with an `id` and a `lang` attribute.
#' @param qstnr TODO
#'
#' @return An integer vector of the same length as `var`.
#' @family aux
#' @export
as_int_vals <- function(var,
                        qstnr = pal::pkg_config_val(key = "cur_qstnr",
                                                    pkg = this_pkg)) {
  var_id <- attr(x = var,
                 which = "id",
                 exact = TRUE)
  
  var_lang <- attr(x = var,
                   which = "lang",
                   exact = TRUE)
  
  purrr::walk(c(var_id,
                var_lang),
              ~ if (is.null(.x)) {
                cli::cli_abort("{.arg var} has no {.var .x} attribute set.")
              })
  
  val_name <- glue::glue("value.{var_lang}")
  lookup <- qstnr %>% dplyr::filter(id == !!var_id & !!as.symbol(val_name) %in% var)
  checkmate::assert_subset(var,
                           choices = lookup[[val_name]])
  
  result <- lookup$value.int[match(var, lookup[[val_name]])]
  attr(result, "id") <- var_id
  result
}
```

### `common_val_scale`

```{r}
#' Get common value scale
#'
#' Determines the greatest common [values scale](https://en.wikipedia.org/wiki/Level_of_measurement) between two value scales `x` and `y` in the hierarchy
#' `r setdiff(value_scales_strict, "ordinal_descending") %>% stringr::str_remove("(?<=^ordinal).+") %>% pal::wrap_chr("*") %>% paste0(collapse = " < ")`.
#'
#' Note that
#' - the value scales *interval* and *ratio* are assumed to always be in **ascending** order.
#' - the value scale *none* is treated specially in the sense that it is ignored when finding the common value scale between *none* and any other value scale.
#'
#' @param x First value scale.
#' @param y Second value scale.
#'
#' @return A character scalar.
#' @family aux
#' @export
#'
#' @examples
#' qstnr::common_val_scale("interval", "nominal")
#' qstnr::common_val_scale("interval", "ratio")
#' qstnr::common_val_scale("ordinal_ascending", "ordinal_descending")
#' 
#' try(
#'   qstnr::common_val_scale("ordinal_descending", "ratio")
#' )
common_val_scale <- function(x,
                             y) {
  rlang::arg_match0(arg = x,
                    values = value_scales)
  rlang::arg_match0(arg = y,
                    values = value_scales)
  
  if ("ordinal_descending" %in% c(x, y) && any(c("interval", "ratio") %in% c(x, y))) {
    cli::cli_abort("Incompatible value scales {.val {y}} and {.val y} provided.")
    
  } else if (x == "none" && y == "none") {
    return("none")
    
  } else if (all(c("ordinal_ascending", "ordinal_descending") %in% c(x, y))) {
    return("nominal")
    
  } else {
    return(intersect(value_scales_strict, c(x,y))[1L])
  }
}
```

### `group_title`

```{r}
#' Get survey group title
#'
#' Extracts the multilanguage group title list for the specified group from the given survey config.
#'
#' @inheritParams gen_qstnr
#' @param group_id Survey group identifier to retrieve the group title of. A character scalar.
#'
#' @return A list.
#' @family aux
#' @export
group_title <- function(survey_config,
                        group_id) {
  
  assert_survey_config(survey_config = survey_config,
                       els = c("item_groups"))
  
  checkmate::assert_choice(group_id,
                           choices = purrr::map_chr(survey_config$item_groups,
                                                    \(x) purrr::chuck(x, "id")))
  survey_config$item_groups |>
    purrr::map(\(x) if (purrr::chuck(x, "id") == group_id) purrr::pluck(x, "title") else NULL) |>
    purrr::compact()
}
```

### `val_set`

```{r}
#' Get value set
#'
#' Returns the value set identified by the provided `id`. The prefix `"desc:"` can be used to reverse the order of the set's values.
#'
#' @inheritParams gen_qstnr
#' @param id String that uniquely identifies the value set.
#'
#' @return A list.
#' @family aux
#' @export
val_set <- function(id,
                    survey_config = survey_config) {
  
  checkmate::assert_string(id)
  assert_survey_config(survey_config = survey_config,
                       els = "value_sets")
  
  is_desc <- startsWith(id, "desc:")
  id %<>% stringr::str_remove("^desc:")
  rlang::arg_match0(arg = id,
                    values = names(survey_config$value_sets))
  
  result <- survey_config$value_sets[[id]]
  
  if (is_desc) {
    result$values %<>% purrr::modify_tree(leaf = rev,
                                          is_node = is.list)
  }
  
  result
}
```

### !`vals`

```{r}
vals <- function(id,
                 survey_config = survey_config) {
  
}
```

## Miscellaneous

### `pkg_config`

```{r}
#' `r this_pkg` package configuration metadata
#'
#' A [tibble][tibble::tbl_df] with metadata of all possible `r this_pkg` package configuration options. See [pal::pkg_config_val()] for more information.
#'
#' @format `r pkgsnip::return_label("data_cols", cols = colnames(pkg_config))`
#' @export
#'
#' @examples
#' qstnr::pkg_config
pkg_config <-
  tibble::tibble(key = character(),
                 default_value = list(),
                 description = character()) %>%
  tibble::add_row(key = "max_cache_lifespan",
                  default_value = list("1 year"),
                  description = paste0("Maximal timespan to preserve the package's [pkgpins](https://rpkg.dev/pkgpins/) cache. Cache entries older than this ",
                                       "will be deleted upon package loading."))
```
