---
editor_options:
  chunk_output_type: console
---

# NOTES

## qstnr format

-   While the qstnr format is supposed to be written in the TOML file format, its schemas are written in the [JSON Schema](https://json-schema.org/) format.

    qstnr validates its TOML files using `pal::toml_validate()` which relies on the external [Taplo CLI](https://taplo.tamasfe.dev/cli/introduction.html)[\^2],
    which is available as a standalone binary for all common platforms [from here](https://github.com/tamasfe/taplo/releases/latest). Taplo allows to define the
    schema to be used directly in the TOML file using the [`schema` header
    directive](https://taplo.tamasfe.dev/configuration/directives.html#the-schema-directive).

## qstnr terminology

qstnr specification

:   Entirety of all qstnr specification parts.

qstnr specification part

:   One of `r cli::ansi_collapse(pal::wrap_chr(all_spec_parts, "`"), last =" or ")\` defining the respective qstnr elements. A part must adhere to its
    respective schema.

qstnr survey configuration

:   Definition of a concrete survey instance using the qstnr framework. This includes all relevant qstnr specification part sources as well as the (grouped)
    qstnr item identifiers in the desired order. Must adhere to the `survey` schema.

## LimeSurvey R clients

Relevant R packages:

-   [LimeRick](https://github.com/kalimu/LimeRick) (abandoned since 2017)
-   [limer](https://github.com/cloudyr/limer) (abandoned since 2018)
-   [**limonaid**](https://r-packages.gitlab.io/limonaid/) (partially based on the work of the limer developer)

## Further information

### Survey design best practices

-   [*Questionnaire Design Tip Sheet* by Harvard University Program on Survey Research](https://psr.iq.harvard.edu/book/questionnaire-design-tip-sheet)
-   [*Writing Survey Questions* by Pew Research Center](https://www.pewresearch.org/our-methods/u-s-surveys/writing-survey-questions/)
-   [*How to design a good survey (guide)* in the LimeSurvey Manual](https://manual.limesurvey.org/How_to_design_a_good_survey_(guide))
-   [*Survey design tips & tricks* by LimeSurvey Consulting](https://limesurvey-consulting.com/survey-design-tips-tricks/)

# INTERNAL

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c("."))
```

## Constants

```{r}
this_pkg <- utils::packageName()
```

### `all_spec_parts`

In the order they should be processed.

```{r}
all_spec_parts <- c("links",
                    "footnotes",
                    "value_sets",
                    "targets",
                    "question_blocks",
                    "items")
```

### `struct_survey`

TODO:

-   Figure out whether it would be feasible to generate the key hierarchy tree(s) directly from the JSON schemas and add specification schemes for the remaining
    parts

NOTES:

-   Pretty-print using:

    ``` r
    struct_survey |>
      pal::flatten_path_tree() |>
      purrr::map_chr(cli::format_inline) |>
      pal::draw_path_tree()
    ```

-   Use `cli::ansi_strip()` after `pal::flatten_path_tree()` to remove the cli formatting.

```{r}
struct_source <- list("[[{.strong source}]]" = list("{.strong list},{.strong file},{.strong url} = {.emph EXPR},{.emph PATH},{.emph URL}"))

struct_survey <- list("{.strong qstnr}" = list(
  "{.strong items}" = c(struct_source,
                        list("{.strong ids}" = list("{.strong {'<questionnaire_block>'}} = [ {.emph id_1}, {.emph id_2}, {.emph ...} ]"))),
  "{.strong question_blocks}" = struct_source,
  "{.strong value_sets}" = struct_source,
  "{.strong targets}" = struct_source,
  "{.strong footnotes}" = struct_source,
  "{.strong links}" = struct_source
))

rm(struct_source)
```

### `value_scales`

```{r}
value_scales <- jsonlite::fromJSON(txt = "data-raw/qstnr/schemas/subschemas/qstnr-item-value_scale.schema.json")$enum
```

### Value prototypes

```{r}
date <- as.Date(NULL)
int <- integer()
float <- numeric()
string <- character()
```

## Functions

### `gen_qstnr`

EXPERIMENTAL!

Test using: `pal::toml_read("/home/salim/Code/own/salim_b/r/pkgs/qstnr/tests/testthat/surveys/simple.toml") |> gen_qstnr()`

```{r}
gen_qstnr <- function(spec) {
  
  # read in and validate spec
  spec <- spec_validate(spec)$qstnr
  
  # materialize spec
  spec_parts <- list()
  
  for (spec_part in intersect(all_spec_parts,
                              names(spec))) {
    
    spec_parts[[spec_part]] <-
      spec %>%
      purrr::chuck(spec_part, "source") %>%
      purrr::map(~ {
        
        src_type <- names(.x)
        
        switch(EXPR = src_type,
               "list" = eval(parse(text = .x[[src_type]])),
               "file" = pal::toml_read(path = glue::glue(.x[[src_type]])),
               cli::cli_abort("Invalid {.field qstnr.items.source} type {.val {src_type}} detected."))
      }) %>%
      purrr::reduce(.f = ~ purrr::list_modify(.x,
                                              !!!.y))
  }
  
  # generate questionnaire from spec
  
  # validate spec parts
  
}
```

### `init_config`

```{r}
init_config <- function(source = NULL,
                        type = all_spec_parts,
                        incl_defaults = TRUE) {
  
  type <- rlang::arg_match(type)
  checkmate::assert_flag(incl_defaults)
  
  opt_name <- paste0("qstnr.", type)
  result <- getOption(opt_name)
  
  if (is.null(result)) {
    
    result <- purrr::map(source,
                         pal::toml_read)
    
    if (incl_defaults) {
      result %<>% c(defaults[[type]])
    }
    
    # TODO!
    result %<>% purrr::reduce(.f = purrr::list_modify,
                              .init = list())
    do.call(what = options,
            args = as.list(setNames(object = result,
                                    nm = opt_name)))
  }
  
  invisible(result)
}
```

### `interpolate`

NOTES:

-   `cli::pluralize()` collapses substituted vectors into a comma-separated string, so we have to fall back to `glue::glue()` for arrays.

```{r}
interpolate <- function(x,
                        key,
                        ...) {

  # assign objects in dots to current env ensuring glue/cli fns respect them
  rlang::env_bind(.env = rlang::current_env(),
                  ...)

  if (key %in% item_keys$key[item_keys$is_scalar]) {

    result <- cli::pluralize(x,
                             .null = NA_character_,
                             .trim = FALSE)
  } else {

    result <-
      x %>%
      purrr::map(.f = glue::glue,
                 .envir = rlang::current_env(),
                 .null = NA_character_,
                 .trim = FALSE) %>%
      unlist()
  }

  result
}
```

# EXPORTED

## `as_int_vals`

```{r}
#' Convert question values to codes
#'
#' Converts character question values to their integer code counterparts. The latter are useful mainly because they're language-independent.
#'
#' @param var Variable holding the question values. A character vector with an `id` and a `lang` attribute.
#' @param qstnr TODO
#'
#' @return An integer vector of the same length as `var`.
#' @export
as_int_vals <- function(var,
                        qstnr = pal::pkg_config_val(key = "cur_qstnr",
                                                    pkg = this_pkg)) {
  var_id <- attr(x = var,
                 which = "id",
                 exact = TRUE)
  
  var_lang <- attr(x = var,
                   which = "lang",
                   exact = TRUE)
  
  purrr::walk(c(var_id,
                var_lang),
              ~ if (is.null(.x)) {
                cli::cli_abort("{.arg var} has no {.var .x} attribute set.")
              })
  
  val_name <- glue::glue("value.{var_lang}")
  lookup <- qstnr %>% dplyr::filter(id == !!var_id & !!as.symbol(val_name) %in% var)
  checkmate::assert_subset(var,
                           choices = lookup[[val_name]])
  
  result <- lookup$value.int[match(var, lookup[[val_name]])]
  attr(result, "id") <- var_id
  result
}
```

## !`init_survey`

```{r}
init_survey <- function(path) {
  
  spec <- pal::toml_read(path = path)
  
  # ensure mandatory keys are present
  ## item IDs
  if (is.null(spec$items$ids)) {
    cli::cli_abort("{.field items.ids} must be set to an array of valid questionnaire item IDs.")
  }
  
  # init config parts
  purrr::walk(all_spec_parts,
              ~ init_config(source = spec[[.x]]$source,
                            type = .x,
                            incl_defaults = !isFALSE(spec[[.x]]$incl_defaults)))
  
}
```

## !`gen_tibble`

```{r}
gen_tibble <- function(spec) {
  
  
}
```

## !`val_ptype`

```{r}
val_ptype <- function(type,
                      size = NULL) {
  # TODO
}
```

## !`vals`

```{r}
vals <- function(id) {
  
  init_config(type = "values")
  
  getOption("qstnr.values")[[id]]
}
```
