---
editor_options:
  chunk_output_type: console
---

# NOTES

## qstnr format

-   While the qstnr format is supposed to be written in the TOML file format, its schemas are written in the [JSON Schema](https://json-schema.org/) format.

    qstnr validates its TOML files using `pal::toml_validate()` which relies on the external [Taplo CLI](https://taplo.tamasfe.dev/cli/introduction.html)[\^2],
    which is available as a standalone binary for all common platforms [from here](https://github.com/tamasfe/taplo/releases/latest). Taplo allows to define the
    schema to be used directly in the TOML file using the [`schema` header
    directive](https://taplo.tamasfe.dev/configuration/directives.html#the-schema-directive).

## qstnr terminology

qstnr specification

:   Entirety of all qstnr specification parts.

qstnr specification part

:   One of `r cli::ansi_collapse(pal::wrap_chr(all_spec_parts, "`"), last =" or ")\` defining the respective qstnr elements. A part must adhere to its
    respective schema.

qstnr survey configuration

:   Definition of a concrete survey instance using the qstnr framework. This includes all relevant qstnr specification part sources as well as the (grouped)
    qstnr item identifiers in the desired order. Must adhere to the `survey` schema.

## LimeSurvey R clients

Relevant R packages:

-   [LimeRick](https://github.com/kalimu/LimeRick) (abandoned since 2017)
-   [limer](https://github.com/cloudyr/limer) (abandoned since 2018)
-   [**limonaid**](https://r-packages.gitlab.io/limonaid/) (partially based on the work of the limer developer)

## Further information

### Survey design best practices

-   [*Questionnaire Design Tip Sheet* by Harvard University Program on Survey Research](https://psr.iq.harvard.edu/book/questionnaire-design-tip-sheet)
-   [*Writing Survey Questions* by Pew Research Center](https://www.pewresearch.org/our-methods/u-s-surveys/writing-survey-questions/)
-   [*How to design a good survey (guide)* in the LimeSurvey Manual](https://manual.limesurvey.org/How_to_design_a_good_survey_(guide))
-   [*Survey design tips & tricks* by LimeSurvey Consulting](https://limesurvey-consulting.com/survey-design-tips-tricks/)

# INTERNAL

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 ":=",
                                 # tidyselect fns
                                 "all_of",
                                 "starts_with",
                                 # other
                                 "description",
                                 "group",
                                 "id",
                                 "init_config",
                                 "lang",
                                 "name",
                                 "path",
                                 "question",
                                 "question_block",
                                 "question_block_filled",
                                 "title",
                                 "value_scale",
                                 "value_sets",
                                 "values",
                                 "values_targets"))
```

## Constants

```{r}
this_pkg <- utils::packageName()
```

### `all_spec_parts`

In the order they should be processed.

```{r}
all_spec_parts <- c("links",
                    "footnotes",
                    "value_sets",
                    "targets",
                    "question_blocks",
                    "items")
```

### `ptype_*`

```{r}
ptype_date <- as.Date(NULL)
ptype_int <- integer()
ptype_float <- numeric()
ptype_string <- character()
```

### `struct_survey`

TODO:

-   Figure out whether it would be feasible to generate the key hierarchy tree(s) directly from the JSON schemas and add specification schemes for the remaining
    parts

NOTES:

-   Pretty-print using:

    ``` r
    struct_survey |>
      pal::flatten_path_tree() |>
      purrr::map_chr(cli::format_inline) |>
      pal::draw_path_tree()
    ```

-   Use `cli::ansi_strip()` after `pal::flatten_path_tree()` to remove the cli formatting.

```{r}
struct_source <- list("[[{.strong source}]]" = list("{.strong list},{.strong file},{.strong url} = {.emph EXPR},{.emph PATH},{.emph URL}"))

struct_survey <- list("{.strong qstnr}" = list(
  "{.strong items}" = c(struct_source,
                        list("{.strong ids}" = list("{.strong {'<questionnaire_block>'}} = [ {.emph id_1}, {.emph id_2}, {.emph ...} ]"))),
  "{.strong question_blocks}" = struct_source,
  "{.strong value_sets}" = struct_source,
  "{.strong targets}" = struct_source,
  "{.strong footnotes}" = struct_source,
  "{.strong links}" = struct_source
))

rm(struct_source)
```

## Functions

### `combine_spec_part_srcs`

NOTES:

-   Currently, only source types `file` and `url` get validated since validation is based on JSON schemas.

```{r}
combine_spec_part_srcs <- function(srcs,
                                   spec_part,
                                   dir,
                                   validate) {
  result <- list()
  
  for (i in seq_along(srcs)) {
    
    src_type <- names(srcs[[i]])
    src_content <- switch(EXPR = src_type,
                          "expr" = spec_part_expr(expr = srcs[[i]]$expr),
                          "file" = spec_part_file(file = srcs[[i]]$file,
                                                  dir = dir,
                                                  spec_part = spec_part,
                                                  validate = validate),
                          "url"  = spec_part_url(url = srcs[[i]]$url,
                                                 spec_part = spec_part,
                                                 validate = validate))
    result %<>% purrr::list_modify(!!!src_content)
  }
  
  result
}
```

### `emph_md`

Properly handles multiline strings and possibly existing emphasis (in simple cases; inline code etc. is not considered).

```{r}
emph_md <- function(x,
                    emph = "*") {
  
  x %>%
    purrr::map_chr(\(x) {
      
      x %>%
        stringr::str_split(pattern = "\n") %>%
        purrr::map(\(x2) {
          x2 %>%
            stringr::str_replace_all(pattern = paste0(stringr::str_escape(emph), "(.*)", stringr::str_escape(emph)),
                                     replacement = "\\1") %>%
            stringr::str_replace_all(pattern = "^(.)",
                                     replacement = paste0(emph, "\\1")) %>%
            stringr::str_replace_all(pattern = "(.)$",
                                     replacement = paste0("\\1", emph))
        }) %>%
        purrr::list_c(ptype = character()) %>%
        stringr::str_flatten(collapse = "\n")
    })
}
```

### `gen_qstnr_row`

```{r}
gen_qstnr_row <- function(item,
                          ...) {
  
  result <- tibble::tibble(.rows = 1L)
  
  for (key in setdiff(item_keys$key, "i")) {
    
    val <- item[[key]]
    is_list_col <- !item_keys$is_scalar[item_keys$key == key] || item_keys$has_lang_subkeys[item_keys$key == key]
    
    if (is.null(val)) {
      
      # assign explicit default val if present
      if (item_keys$has_default[item_keys$key == key]) {
        val <- unlist(item_keys$default_val[item_keys$key == key],
                      recursive = FALSE)
        
        # assign NA of proper type if non-list col
      } else if (!is_list_col) {
        val <- unlist(item_keys$default_val[item_keys$key == key],
                      recursive = FALSE)[NA]
      }
      # perform possible string interpolation
    } else if (item_keys$type[item_keys$key == key] == "character") {
      
      val %<>% purrr::modify_tree(leaf = \(x1) purrr::map_chr(x1, \(x2) interpolate(x2, ...)),
                                  is_node = is.list)
    }
    
    if (is_list_col) {
      val %<>% list()
    }
    
    result %<>% tibble::add_column(!!key := val)
  }
  
  result
}
```

### `gen_qstnr_rows`

Recursively iterates over all the item iterators.

```{r}
gen_qstnr_rows <- function(item,
                           i = 1L,
                           i_list = list()) {
  
  if (i < length(item$i)) {
    
    result <-
      purrr::map(item$i[[i]],
                 \(cur_i) {
                   
                   i_list %<>% c(rlang::list2("i{i}" := cur_i))
                   
                   gen_qstnr_rows(item = item,
                                  i = i + 1L,
                                  i_list = i_list)
                 }) %>%
      purrr::list_rbind()
    
  } else {
    
    result <-
      purrr::map(item$i[[i]],
                 \(cur_i) {
                   
                   i_list %<>% c(rlang::list2("i{i}" := cur_i))
                   
                   gen_qstnr_row(item = item,
                                 !!!i_list)
                   
                 }) %>%
      purrr::list_rbind()
  }
  
  result
}
```

### `interpolate`

```{r}
interpolate <- function(x,
                        ...) {

  # assign objects in dots to current env ensuring `cli::pluralize()` finds them
  rlang::env_bind(.env = rlang::current_env(),
                  ...)
  
  cli::pluralize(x,
                 .null = NA_character_,
                 .trim = FALSE)
}
```

### `spec_part_expr`

```{r}
spec_part_expr <- function(expr) {
  
  eval(expr = parse(text = expr),
       # eval in empty env to avoid unintended results
       envir = emptyenv()) %>%
    checkmate::assert_list(any.missing = FALSE)
}
```

### `spec_part_file`

```{r}
spec_part_file <- function(file,
                           dir,
                           spec_part,
                           validate) {
  
  path <- fs::path(dir, file)
  
  if (validate) {
    pal::toml_validate(input = path,
                       from_file = TRUE,
                       schema = glue::glue("https://qstnr.rpkg.dev/dev/schemas/qstnr-{spec_part}.schema.json"))
  }
  
  pal::toml_read(input = path,
                 from_file = TRUE)
}
```

### `spec_part_url`

NOTES:

-   Use `url = "https://qstnr.rpkg.dev/dev/configs/default/items.toml"` to test.

```{r}
spec_part_url <- function(url,
                          spec_part,
                          validate) {
  toml_content <-
    httr::RETRY(verb = "GET",
              url = url) %>%
    httr::content(as = "text", encoding = "UTF-8")
  
  if (validate) {
    pal::toml_validate(input = toml_content,
                       from_file = FALSE,
                       schema = glue::glue("https://qstnr.rpkg.dev/dev/schemas/qstnr-{spec_part}.schema.json"))
  }
  
  pal::toml_read(input = toml_content,
                 from_file = FALSE)
}
```

# EXPORTED

## Survey preparation

### DESCRIPTION

Functions to process raw survey configurations.

### `read_survey`

```{r}
#' Read in survey config
#'
#' Assembles a raw TOML survey configuration into a combined survey configuration list.
#'
#' @param path Path to the survey config TOML file. A character scalar.
#' @param validate Whether or not to validate all input TOML files, i.e. ensure that they adhere to their respective schemas.
#'
#' @return A list containing the combined survey configuration.
#' @family survey_prep
#' @export
read_survey <- function(path,
                        validate = FALSE) {
  
  checkmate::assert_flag(validate)
  
  if (validate) {
    pal::toml_validate(input = path,
                       schema = "https://qstnr.rpkg.dev/dev/schemas/qstnr-survey.schema.json")
  }
  
  dir <- fs::path_dir(path) %>% fs::path_abs()
  survey_config_raw <- pal::toml_read(input = path)
  spec_parts <-
    names(survey_config_raw$qstnr) %>%
    intersect(all_spec_parts) %>%
    pal::order_by(by = all_spec_parts) %>%
    rlang::set_names() %>%
    purrr::map(~ {
      combine_spec_part_srcs(srcs = survey_config_raw$qstnr[[.x]]$source,
                             spec_part = .x,
                             dir = dir,
                             validate = validate)
    })
  # keep only items that are actually needed
  spec_parts$items %<>% purrr::keep_at(at = unlist(purrr::map_depth(.x = survey_config_raw$qstnr$items$group,
                                                                    .depth = 1L,
                                                                    .f = \(x) x$item_ids)))
  # extract non-spec-part stuff
  other <- survey_config_raw$qstnr %>% purrr::keep_at(at = setdiff(survey_config_keys,
                                                                   all_spec_parts))
  # create final list struct
  rlang::list2(item_groups = survey_config_raw$qstnr$items$group,
               !!!spec_parts,
               !!!other)
}
```

## Questionnaire generation

### DESCRIPTION

Functions to generate different representations of a questionnaire from a combined survey configuration.

### `gen_qstnr`

```{r}
#' Generate questionnaire tibble
#'
#' @param survey_config Survey configuration list as returned by [read_survey()].
#'
#' @return `r pkgsnip::return_label("data")`
#' @family qstnr_gen
#' @export
gen_qstnr <- function(survey_config) {
  
  result <-
    survey_config$item_groups %>%
    rlang::set_names(nm = purrr::map_depth(., 1L, \(x) x$id)) %>%
    # for each item group
    purrr::map(
      # for each item ID
      \(group) {
        purrr::map(
          group$item_ids,
          \(id) {
            
            item <- survey_config$items[[id]]
            
            if (length(item[["i"]]) > 0L) {
              return(gen_qstnr_rows(item = item))
            } else {
              return(gen_qstnr_row(item = item))
            }
          }) %>%
          purrr::list_rbind()
      }) %>%
    purrr::list_rbind(names_to = "group") %>%
    # add overall item numbering
    tibble::rowid_to_column(var = "order") %>%
    # replace `value_sets` with actual `values`
    dplyr::group_by(id) %>%
    dplyr::group_modify(\(d, k) {
      
      val_set_ids <- unlist(d$value_sets)
      
      # return early in case of no ext value sets
      if (length(val_set_ids) == 1L && val_set_ids == "values") {
        return(d %>% dplyr::select(-value_sets))
      }
      
      # combine all (int and ext) value sets
      d_new <-
        val_set_ids %>%
        purrr::map(\(id) {
          # handle internal value set
          if (id == "values") return(d %>% dplyr::select(value_scale, values))
          # handle external value sets
          val_set <- val_set(id = id,
                             survey_config = survey_config)
          gen_qstnr_row(val_set) %>% dplyr::select(all_of(setdiff(names(val_set), "id")))
        }) %>%
        purrr::reduce(\(d1, d2) {
          list(value_scale = common_val_scale(d1$value_scale, d2$value_scale),
               values = purrr::list_merge(d1$values, !!!d2$values))
        })
      
      d %<>% dplyr::select(-value_sets)
      d$value_scale <- d_new$value_scale
      d$values <- d_new$values
      
      d
    }) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(
      # complement with default `values.targets` and convert `values.int` to type integer
      dplyr::across(values,
                    \(x) {
                      purrr::map(x,
                                 \(x2) {
                                   if (is.null(x2$targets)) {
                                     x2$targets <- rep("all", length(x2$int))
                                   }
                                   x2$int %<>% as.integer()
                                   x2})}),
      # reduce to English `title` and `description` only for now
      title = purrr::map_chr(title, \(x) x$en),
      description = purrr::map_chr(description, \(x) x$en)) %>%
    # restore original order
    dplyr::arrange(order)
  
  # warn if item and item group IDs overlap
  ids_overlap <- intersect(result$group,
                           result$id)
  
  if (length(ids_overlap) > 0L) {
    cli::cli_warn("Item group identifiers and item identifiers must be overall unique for further processing. Overlapping IDs include {.val {ids_overlap}}.")
  }
  
  result
}
```

### `unnest_qstnr`

NOTES:

-   We have to unnest the `values` col separately from the `question` col since they can have different lengths.

```{r}
#' Unnest questionnaire tibble
#'
#' Unnests a nested qstnr tibble as returned by [gen_qstnr()] into one row per question `lang` and `id`.
#'
#' @param qstnr Nested questionnaire tibble as returned by [gen_qstnr()].
#'
#' @return `r pkgsnip::return_label("data")`
#' @family qstnr_gen
#' @export
unnest_qstnr <- function(qstnr) {
  
  qstnr %>%
    dplyr::group_by(id) %>%
    dplyr::group_modify(\(d, k) {
      
      lang_specific_subset <-
        d %>%
        dplyr::select(question) %>%
        # unnest lang-subkey `question`
        tidyr::unnest_longer(col = question,
                             indices_to = "lang",
                             keep_empty = TRUE,
                             simplify = FALSE)
      
      d$values_int <- list(d$values[[1L]]$int)
      d$values_targets <- list(d$values[[1L]]$targets)
      d$values <- list(d$values[[1L]] %>% purrr::keep_at(at = nchar(names(.)) == 2L))
      
      lang_specific_subset <-
        d %>%
        dplyr::select(values) %>%
        # unnest lang-subkey `values`
        tidyr::unnest_longer(col = values,
                             indices_to = "lang",
                             keep_empty = TRUE,
                             simplify = FALSE) %>%
        dplyr::full_join(y = lang_specific_subset,
                         by = "lang")
      d %>%
        dplyr::select(-c(question, values)) %>%
        dplyr::cross_join(y = lang_specific_subset)
    }) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(order)
}
```

### `unnest_qstnr_vals`

```{r}
#' Unnest questionnaire tibble's item values
#'
#' Unnests a semi-unnested qstnr tibble as returned by [unnest_qstnr()] into one row per question `lang`, `id` and `value`.
#'
#' @param qstnr Semi-unnested questionnaire tibble as returned by [gen_qstnr()].
#'
#' @return `r pkgsnip::return_label("data")`
#' @family qstnr_gen
#' @export
unnest_qstnr_vals <- function(qstnr) {
  
  qstnr %>%
    # complement `values` with `values_int`
    dplyr::group_by(id, lang) %>%
    dplyr::group_modify(\(d, k) {
      
      if (is.null(d$values[[1L]])) {
        d$values <- purrr::map(d$values_int,
                               \(x) as.character(x))
      }
      
      d
    }) %>%
    dplyr::ungroup() %>%
    # harmonize `values_targets` struct
    dplyr::mutate(values_targets = purrr::map(values_targets,
                                              \(x) {
                                                if (purrr::pluck_depth(x) < 2L) {
                                                  x %<>% as.list()
                                                }
                                                x
                                              })) %>%
    # unnest `values*` cols
    tidyr::unnest_longer(col = starts_with("values")) %>%
    dplyr::rename_with(.cols = starts_with("values"),
                       .fn = \(x) stringr::str_replace(string = x,
                                                       pattern = "^values",
                                                       replacement = "value"))
}
```

### `gen_qmd_qstnr`

```{r}
#' Generate Quarto Markdown questionnaire
#'
#' @inheritParams gen_qstnr
#' @param qstnr Unnested questionnaire tibble as returned by [unnest_qstnr()].
#' @param lang Language in which to output the questionnaire. A character scalar.
#' @param path Path to write the generated questionnaire file to. A character scalar.
#' @param add_item_ids Whether or not to add questionnaire item identifiers next to the question texts.
#'
#' @return `qstnr`, invisibly.
#' @family qstnr_gen
#' @export
gen_qmd_qstnr <- function(qstnr,
                          survey_config,
                          lang,
                          path,
                          add_item_ids = TRUE) {
  
  checkmate::assert_data_frame(qstnr,
                               all.missing = FALSE,
                               min.rows = 1L)
  
  missing_cols <- setdiff(c("lang", "group", "id", "question_block", "question", "values", "is_mandatory", "allow_multiple_answers"),
                          colnames(qstnr))
  if (length(missing_cols) > 0L) {
    cli::cli_abort("Mandatory columns {.var missing_cols} are missing from argument {.arg qstnr}.")
  }
  checkmate::assert_list(survey_config,
                         all.missing = FALSE)
  missing_els <- setdiff(c("question_blocks", "title", "intro", "outro"),
                         names(survey_config))
  if (length(missing_els) > 0L) {
    cli::cli_abort("Mandatory elements {.var missing_els} are missing from argument {.arg survey_config}.")
  }
  rlang::arg_match0(arg = lang,
                    values = unique(qstnr$lang))
  checkmate::assert_path_for_output(path,
                                    overwrite = TRUE)
  checkmate::assert_flag(add_item_ids)
  
  notice_mandatory <- c(pal::wrap_chr(survey_config$notice$mandatory[[lang]] %||%
                                        notice$mandatory[[lang]] %||%
                                        notice$mandatory$en,
                                      wrap = "*"),
                        "")
  notice_multiple_answers <- c(pal::wrap_chr(survey_config$notice$multiple_answers[[lang]] %||%
                                               notice$multiple_answers[[lang]] %||%
                                               notice$multiple_answers$en,
                                             wrap = "*"),
                               "")
  survey_blocks <-
    qstnr %>%
    dplyr::filter(lang == !!lang) %>%
    # fill missing `question_block`s with `id`s to avoid order mess up further below
    dplyr::mutate(question_block_filled = dplyr::if_else(is.na(question_block),
                                                         id,
                                                         question_block),
                  # note that we need to rely on factors to avoid alphabetical group key ordering further below
                  dplyr::across(c(group, question_block_filled, id),
                                \(x) factor(x,
                                            levels = unique(x)))) %>%
    dplyr::group_by(group) %>%
    dplyr::group_map(\(d1, k1) {
      
      question_blocks <-
        d1 %>%
        dplyr::group_by(question_block_filled) %>%
        dplyr::group_map(\(d2, k2) {
          
          is_question_block <- length(unique(d2$id)) > 1L
          is_question_block_compact <- is_question_block && length(unique(d2$values)) == 1L
          
          questions <-
            d2 %>%
            dplyr::group_by(id) %>%
            dplyr::group_map(\(d3, k3) {
              
              q_text <- emph_md(unlist(d3$question),
                                emph = "**")
              q_id <- paste0("^`", k3$id, "`^")
              
              # layout is conditional on whether the question is part of a block or not
              if (!is_question_block) {
                question <- c(paste0(q_text, "  "[add_item_ids]),
                              q_id[add_item_ids],
                              "",
                              paste0("- ", unlist(d3$values)),
                              "",
                              notice_mandatory[d3$is_mandatory],
                              notice_multiple_answers[d3$allow_multiple_answers])
              } else {
                question <- c(paste0("- ", q_text, " ", q_id[add_item_ids]))
                
                if (!is_question_block_compact) {
                  question %<>% c(paste0("  - ", unlist(d3$values)))
                }
              }
              
              question
            }) %>%
            purrr::list_c(ptype = character())
          
          c(survey_config$question_blocks[[as.character(k2$question_block_filled)]]$intro[[lang]][is_question_block],
            ""[is_question_block],
            questions,
            ""[is_question_block_compact],
            paste0("Es kann jeweils mit ", pal::prose_ls(unlist(d2$values[1L]), last_sep = " oder ", wrap = '"'),
                   " geantwortet werden.")[is_question_block_compact],
            ""[is_question_block],
            notice_mandatory[is_question_block && d2$is_mandatory[1L]],
            notice_multiple_answers[is_question_block && d2$allow_multiple_answers[1L]])
        }) %>%
        purrr::list_c(ptype = character())
      
      pretty_group <-
        k1$group %>%
        stringr::str_replace_all("_", " ") %>%
        stringr::str_to_title() %>%
        emph_md(emph = "**")
      
      c(paste0("## Block ", pretty_group),
        "",
        question_blocks,
        "",
        "{{< pagebreak >}}",
        "")
    }) %>%
    purrr::list_c(ptype = character())
  
  c(paste0("# ", survey_config$title[[lang]]),
    "",
    survey_config$intro[[lang]],
    "",
    "{{< pagebreak >}}",
    "",
    survey_blocks,
    survey_config$outro[[lang]]) %>%
    brio::write_lines(path = path)
}
```

## Auxiliary

### `as_int_vals`

TODO: Rethink and finish this.

```{r}
#' Convert question values to codes
#'
#' Converts character question values to their integer code counterparts. The latter are useful mainly because they're language-independent.
#'
#' @param var Variable holding the question values. A character vector with an `id` and a `lang` attribute.
#' @param qstnr TODO
#'
#' @return An integer vector of the same length as `var`.
#' @family aux
#' @export
as_int_vals <- function(var,
                        qstnr = pal::pkg_config_val(key = "cur_qstnr",
                                                    pkg = this_pkg)) {
  var_id <- attr(x = var,
                 which = "id",
                 exact = TRUE)
  
  var_lang <- attr(x = var,
                   which = "lang",
                   exact = TRUE)
  
  purrr::walk(c(var_id,
                var_lang),
              ~ if (is.null(.x)) {
                cli::cli_abort("{.arg var} has no {.var .x} attribute set.")
              })
  
  val_name <- glue::glue("value.{var_lang}")
  lookup <- qstnr %>% dplyr::filter(id == !!var_id & !!as.symbol(val_name) %in% var)
  checkmate::assert_subset(var,
                           choices = lookup[[val_name]])
  
  result <- lookup$value.int[match(var, lookup[[val_name]])]
  attr(result, "id") <- var_id
  result
}
```

### `common_val_scale`

```{r}
#' Get common value scale
#'
#' Determines the greatest common [values scale](https://en.wikipedia.org/wiki/Level_of_measurement) between two value scales `x` and `y` in the hierarchy
#' `r setdiff(value_scales_strict, "ordinal_descending") %>% stringr::str_remove("(?<=^ordinal).+") %>% pal::wrap_chr("*") %>% paste0(collapse = " < ")`.
#'
#' Note that
#' - the value scales *interval* and *ratio* are assumed to always be in **ascending** order.
#' - the value scale *none* is treated specially in the sense that it is ignored when finding the common value scale between *none* and any other value scale.
#'
#' @param x First value scale.
#' @param y Second value scale.
#'
#' @return A character scalar.
#' @family aux
#' @export
#'
#' @examples
#' qstnr::common_val_scale("interval", "nominal")
#' qstnr::common_val_scale("interval", "ratio")
#' qstnr::common_val_scale("ordinal_ascending", "ordinal_descending")
#' 
#' try(
#'   qstnr::common_val_scale("ordinal_descending", "ratio")
#' )
common_val_scale <- function(x,
                             y) {
  rlang::arg_match0(arg = x,
                    values = value_scales)
  rlang::arg_match0(arg = y,
                    values = value_scales)
  
  if ("ordinal_descending" %in% c(x, y) && any(c("interval", "ratio") %in% c(x, y))) {
    cli::cli_abort("Incompatible value scales {.val {y}} and {.val y} provided.")
    
  } else if (x == "none" && y == "none") {
    return("none")
    
  } else if (all(c("ordinal_ascending", "ordinal_descending") %in% c(x, y))) {
    return("nominal")
    
  } else {
    return(intersect(value_scales_strict, c(x,y))[1L])
  }
}
```

### `val_set`

```{r}
#' Get value set
#'
#' Returns the value set identified by the provided `id`. The prefix `"desc:"` can be used to reverse the order of the set's values.
#'
#' @inheritParams gen_qstnr
#' @param id String that uniquely identifies the value set.
#'
#' @return A list.
#' @family aux
#' @export
val_set <- function(id,
                    survey_config = survey_config) {
  
  is_desc <- startsWith(id, "desc:")
  id %<>% stringr::str_remove("^desc:")
  rlang::arg_match0(arg = id,
                    values = names(survey_config$value_sets))
  
  result <- survey_config$value_sets[[id]]
  
  if (is_desc) {
    result$values %<>% purrr::modify_tree(leaf = rev,
                                          is_node = is.list)
  }
  
  result
}
```

### !`val_ptype`

```{r}
val_ptype <- function(type,
                      size = NULL) {
  # TODO
}
```

### !`vals`

```{r}
vals <- function(id,
                 survey_config = survey_config) {
  
}
```
