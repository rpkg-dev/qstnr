# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/qstnr.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literate programming approach used applying the R Markdown format.

# qstnr: Helps Creating and Maintaining Survey Questionnaires
# Copyright (C) 2023 Salim Br√ºggemann
# 
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

utils::globalVariables(names = c(".",
                                 ":=",
                                 "all_of",
                                 "description",
                                 "group",
                                 "id",
                                 "init_config",
                                 "name",
                                 "path",
                                 "question",
                                 "question_block",
                                 "question_block_filled",
                                 "title",
                                 "value_scale",
                                 "value_sets",
                                 "values"))

this_pkg <- utils::packageName()

all_spec_parts <- c("links",
                    "footnotes",
                    "value_sets",
                    "targets",
                    "question_blocks",
                    "items")

ptype_date <- as.Date(NULL)
ptype_int <- integer()
ptype_float <- numeric()
ptype_string <- character()

struct_source <- list("[[{.strong source}]]" = list("{.strong list},{.strong file},{.strong url} = {.emph EXPR},{.emph PATH},{.emph URL}"))

struct_survey <- list("{.strong qstnr}" = list(
  "{.strong items}" = c(struct_source,
                        list("{.strong ids}" = list("{.strong {'<questionnaire_block>'}} = [ {.emph id_1}, {.emph id_2}, {.emph ...} ]"))),
  "{.strong question_blocks}" = struct_source,
  "{.strong value_sets}" = struct_source,
  "{.strong targets}" = struct_source,
  "{.strong footnotes}" = struct_source,
  "{.strong links}" = struct_source
))

rm(struct_source)

combine_spec_part_srcs <- function(srcs,
                                   spec_part,
                                   dir,
                                   validate) {
  result <- list()
  
  for (i in seq_along(srcs)) {
    
    src_type <- names(srcs[[i]])
    src_content <- switch(EXPR = src_type,
                          "expr" = spec_part_expr(expr = srcs[[i]]$expr),
                          "file" = spec_part_file(file = srcs[[i]]$file,
                                                  dir = dir,
                                                  spec_part = spec_part,
                                                  validate = validate),
                          "url"  = spec_part_url(url = srcs[[i]]$url,
                                                 spec_part = spec_part,
                                                 validate = validate))
    result %<>% purrr::list_modify(!!!src_content)
  }
  
  result
}

emph_md <- function(x,
                    emph = "*") {
  
  x %>%
    purrr::map_chr(\(x) {
      
      x %>%
        stringr::str_split(pattern = "\n") %>%
        purrr::map(\(x2) {
          x2 %>%
            stringr::str_replace_all(pattern = paste0(stringr::str_escape(emph), "(.*)", stringr::str_escape(emph)),
                                     replacement = "\\1") %>%
            stringr::str_replace_all(pattern = "^(.)",
                                     replacement = paste0(emph, "\\1")) %>%
            stringr::str_replace_all(pattern = "(.)$",
                                     replacement = paste0("\\1", emph))
        }) %>%
        purrr::list_c(ptype = character()) %>%
        stringr::str_flatten(collapse = "\n")
    })
}

gen_qstnr_row <- function(item,
                          ...) {
  
  result <- tibble::tibble(.rows = 1L)
  
  for (key in setdiff(item_keys$key, "i")) {
    
    val <- item[[key]]
    is_list_col <- !item_keys$is_scalar[item_keys$key == key] || item_keys$has_lang_subkeys[item_keys$key == key]
    
    if (is.null(val)) {
      
      # assign explicit default val if present
      if (item_keys$has_default[item_keys$key == key]) {
        val <- unlist(item_keys$default_val[item_keys$key == key],
                      recursive = FALSE)
        
        # assign NA of proper type if non-list col
      } else if (!is_list_col) {
        val <- unlist(item_keys$default_val[item_keys$key == key],
                      recursive = FALSE)[NA]
      }
      # perform possible string interpolation
    } else if (item_keys$type[item_keys$key == key] == "character") {
      
      val %<>% purrr::modify_tree(leaf = \(x1) purrr::map_chr(x1, \(x2) interpolate(x2, ...)),
                                  is_node = is.list)
    }
    
    if (is_list_col) {
      val %<>% list()
    }
    
    result %<>% tibble::add_column(!!key := val)
  }
  
  result
}

gen_qstnr_rows <- function(item,
                           i = 1L,
                           i_list = list()) {
  
  if (i < length(item$i)) {
    
    result <-
      purrr::map(item$i[[i]],
                 \(cur_i) {
                   
                   i_list %<>% c(rlang::list2("i{i}" := cur_i))
                   
                   gen_qstnr_rows(item = item,
                                  i = i + 1L,
                                  i_list = i_list)
                 }) %>%
      purrr::list_rbind()
    
  } else {
    
    result <-
      purrr::map(item$i[[i]],
                 \(cur_i) {
                   
                   i_list %<>% c(rlang::list2("i{i}" := cur_i))
                   
                   gen_qstnr_row(item = item,
                                 !!!i_list)
                   
                 }) %>%
      purrr::list_rbind()
  }
  
  result
}

interpolate <- function(x,
                        ...) {

  # assign objects in dots to current env ensuring `cli::pluralize()` finds them
  rlang::env_bind(.env = rlang::current_env(),
                  ...)
  
  cli::pluralize(x,
                 .null = NA_character_,
                 .trim = FALSE)
}

spec_part_expr <- function(expr) {
  
  eval(expr = parse(text = expr),
       # eval in empty env to avoid unintended results
       envir = emptyenv()) %>%
    checkmate::assert_list(any.missing = FALSE)
}

spec_part_file <- function(file,
                           dir,
                           spec_part,
                           validate) {
  if (validate) {
    pal::toml_validate(input = path,
                       from_file = TRUE,
                       schema = glue::glue("https://qstnr.rpkg.dev/dev/schemas/qstnr-{spec_part}.schema.json"))
  }
  
  pal::toml_read(input = fs::path(dir, file),
                 from_file = TRUE)
}

spec_part_url <- function(url,
                          spec_part,
                          validate) {
  toml_content <-
    httr::RETRY(verb = "GET",
              url = url) %>%
    httr::content(as = "text", encoding = "UTF-8")
  
  if (validate) {
    pal::toml_validate(input = toml_content,
                       from_file = FALSE,
                       schema = glue::glue("https://qstnr.rpkg.dev/dev/schemas/qstnr-{spec_part}.schema.json"))
  }
  
  pal::toml_read(input = toml_content,
                 from_file = FALSE)
}

#' Read in survey config
#'
#' @param path Path to the survey config TOML file. A character scalar.
#' @param validate Whether or not to validate all input TOML files, i.e. ensure that they adhere to their respective schemas.
#'
#' @return A list containing the combined survey configuration. Additionally, 
#' @export
read_survey <- function(path,
                        validate = FALSE) {
  
  checkmate::assert_flag(validate)
  
  if (validate) {
    pal::toml_validate(input = path,
                       schema = "https://qstnr.rpkg.dev/dev/schemas/qstnr-survey.schema.json")
  }
  
  dir <- fs::path_dir(path) %>% fs::path_abs()
  survey_config_raw <- pal::toml_read(input = path)
  spec_parts <-
    names(survey_config_raw$qstnr) %>%
    intersect(all_spec_parts) %>%
    pal::order_by(by = all_spec_parts) %>%
    rlang::set_names() %>%
    purrr::map(~ {
      combine_spec_part_srcs(srcs = survey_config_raw$qstnr[[.x]]$source,
                             spec_part = .x,
                             dir = dir,
                             validate = validate)
    })
  # keep only items that are actually needed
  spec_parts$items %<>% purrr::keep_at(at = unlist(purrr::map_depth(.x = survey_config_raw$qstnr$items$group,
                                                                    .depth = 1L,
                                                                    .f = \(x) x$item_ids)))
  # extract non-spec-part stuff
  other <- survey_config_raw$qstnr %>% purrr::keep_at(at = setdiff(survey_config_keys,
                                                                   all_spec_parts))
  # create final list struct
  rlang::list2(item_groups = survey_config_raw$qstnr$items$group,
               !!!spec_parts,
               !!!other)
}

#' Generate questionnaire tibble
#'
#' @param survey_config Survey configuration list as returned by [read_survey()].
#'
#' @return `r pkgsnip::return_label("data")`
#' @export
gen_qstnr <- function(survey_config) {
  
  result <-
    survey_config$item_groups %>%
    rlang::set_names(nm = purrr::map_depth(., 1L, \(x) x$id)) %>%
    # for each item group
    purrr::map(
      # for each item ID
      \(group) {
        purrr::map(
          group$item_ids,
          \(id) {
            
            item <- survey_config$items[[id]]
            
            if (length(item[["i"]]) > 0L) {
              return(gen_qstnr_rows(item = item))
            } else {
              return(gen_qstnr_row(item = item))
            }
          }) %>%
          purrr::list_rbind()
      }) %>%
    purrr::list_rbind(names_to = "group") %>%
    # add overall item numbering
    tibble::rowid_to_column(var = "order") %>%
    # replace `value_sets` with actual `values`
    dplyr::group_by(id) %>%
    dplyr::group_modify(\(d, k) {
      
      val_set_ids <- unlist(d$value_sets)
      
      # return early in case of no ext value sets
      if (length(val_set_ids) == 1L && val_set_ids == "values") {
        return(d %>% dplyr::select(-value_sets))
      }
      
      # combine all (int and ext) value sets
      d_new <-
        val_set_ids %>%
        purrr::map(\(id) {
          # handle internal value set
          if (id == "values") return(d %>% dplyr::select(value_scale, values))
          # handle external value sets
          val_set <- val_set(id = id,
                             survey_config = survey_config)
          gen_qstnr_row(val_set) %>% dplyr::select(all_of(setdiff(names(val_set), "id")))
        }) %>%
        purrr::reduce(\(d1, d2) {
          list(value_scale = common_val_scale(d1$value_scale, d2$value_scale),
               values = purrr::list_merge(d1$values, !!!d2$values))
        })
      
      d %<>% dplyr::select(-value_sets)
      d$value_scale <- d_new$value_scale
      d$values <- d_new$values
      
      d
    }) %>%
    dplyr::ungroup() %>%
    # reduce to English `title` and `description` only for now
    dplyr::mutate(title = purrr::map_chr(title, \(x) x$en),
                  description = purrr::map_chr(description, \(x) x$en)) %>%
    # restore original order
    dplyr::arrange(order)
  
  # warn if item and item group IDs overlap
  ids_overlap <- intersect(result$group,
                           result$id)
  
  if (length(ids_overlap) > 0L) {
    cli::cli_warn("Item group identifiers and item identifiers must be overall unique for further processing. Overlapping IDs include {.val {ids_overlap}}.")
  }
  
  result
}

#' Unnest questionnaire tibble
#'
#' @param qstnr Nested questionnaire tibble as returned by [gen_qstnr()].
#'
#' @return `r pkgsnip::return_label("data")`
#' @export
unnest_qstnr <- function(qstnr) {
  
  qstnr %>%
    dplyr::group_by(id) %>%
    dplyr::group_modify(\(d, k) {
      
      lang_specific_subset <-
        d %>%
        dplyr::select(question) %>%
        # unnest lang-subkey `question`
        tidyr::unnest_longer(col = question,
                             indices_to = "lang",
                             keep_empty = TRUE,
                             simplify = FALSE)
      
      d$values_int <- list(d$values[[1L]]$int)
      d$values_targets <- list(d$values[[1L]]$targets)
      d$values <- list(d$values[[1L]] %>% purrr::keep_at(at = nchar(names(.)) == 2L))
      
      lang_specific_subset <-
        d %>%
        dplyr::select(values) %>%
        # unnest lang-subkey `values`
        tidyr::unnest_longer(col = values,
                             indices_to = "lang",
                             keep_empty = TRUE,
                             simplify = FALSE) %>%
        dplyr::full_join(y = lang_specific_subset,
                         by = "lang")
      d %>%
        dplyr::select(-c(question, values)) %>%
        dplyr::cross_join(y = lang_specific_subset)
    }) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(order)
}

#' Generate Quarto Markdown questionnaire
#'
#' @inheritParams gen_qstnr
#' @param qstnr Unnested questionnaire tibble as returned by [unnest_qstnr()].
#' @param lang Language in which to output the questionnaire. A character scalar.
#' @param path Path to write the generated questionnaire file to. A character scalar.
#' @param add_item_ids Whether or not to add questionnaire item identifiers next to the question texts.
#'
#' @return `qstnr`, invisibly.
#' @export
gen_qmd_qstnr <- function(qstnr,
                          survey_config,
                          lang,
                          path,
                          add_item_ids = TRUE) {
  
  checkmate::assert_data_frame(qstnr,
                               all.missing = FALSE,
                               min.rows = 1L)
  
  missing_cols <- setdiff(c("lang", "group", "id", "question_block", "question", "values", "is_mandatory", "allow_multiple_answers"),
                          colnames(qstnr))
  if (length(missing_cols) > 0L) {
    cli::cli_abort("Mandatory columns {.var missing_cols} are missing from argument {.arg qstnr}.")
  }
  checkmate::assert_list(survey_config,
                         all.missing = FALSE)
  missing_els <- setdiff(c("question_blocks", "title", "intro", "outro"),
                         names(survey_config))
  if (length(missing_els) > 0L) {
    cli::cli_abort("Mandatory elements {.var missing_els} are missing from argument {.arg survey_config}.")
  }
  rlang::arg_match0(arg = lang,
                    values = unique(qstnr$lang))
  checkmate::assert_path_for_output(path,
                                    overwrite = TRUE)
  checkmate::assert_flag(add_item_ids)
  
  notice_mandatory <- c(pal::wrap_chr(survey_config$notice$mandatory[[lang]] %||%
                                        notice$mandatory[[lang]] %||%
                                        notice$mandatory$en,
                                      wrap = "*"),
                        "")
  notice_multiple_answers <- c(pal::wrap_chr(survey_config$notice$multiple_answers[[lang]] %||%
                                               notice$multiple_answers[[lang]] %||%
                                               notice$multiple_answers$en,
                                             wrap = "*"),
                               "")
  survey_blocks <-
    qstnr %>%
    dplyr::filter(lang == !!lang) %>%
    # fill missing `question_block`s with `id`s to avoid order mess up further below
    dplyr::mutate(question_block_filled = dplyr::if_else(is.na(question_block),
                                                         id,
                                                         question_block),
                  # note that we need to rely on factors to avoid alphabetical group key ordering further below
                  dplyr::across(c(group, question_block_filled, id),
                                \(x) factor(x,
                                            levels = unique(x)))) %>%
    dplyr::group_by(group) %>%
    dplyr::group_map(\(d1, k1) {
      
      question_blocks <-
        d1 %>%
        dplyr::group_by(question_block_filled) %>%
        dplyr::group_map(\(d2, k2) {
          
          is_question_block <- length(unique(d2$id)) > 1L
          is_question_block_compact <- is_question_block && length(unique(d2$values)) == 1L
          
          questions <-
            d2 %>%
            dplyr::group_by(id) %>%
            dplyr::group_map(\(d3, k3) {
              
              q_text <- emph_md(unlist(d3$question),
                                emph = "**")
              q_id <- paste0("^`", k3$id, "`^")
              
              # layout is conditional on whether the question is part of a block or not
              if (!is_question_block) {
                question <- c(paste0(q_text, "  "[add_item_ids]),
                              q_id[add_item_ids],
                              "",
                              paste0("- ", unlist(d3$values)),
                              "",
                              notice_mandatory[d3$is_mandatory],
                              notice_multiple_answers[d3$allow_multiple_answers])
              } else {
                question <- c(paste0("- ", q_text, " ", q_id[add_item_ids]))
                
                if (!is_question_block_compact) {
                  question %<>% c(paste0("  - ", unlist(d3$values)))
                }
              }
              
              question
            }) %>%
            purrr::list_c(ptype = character())
          
          c(survey_config$question_blocks[[as.character(k2$question_block_filled)]]$intro[[lang]][is_question_block],
            ""[is_question_block],
            questions,
            ""[is_question_block_compact],
            paste0("Es kann jeweils mit ", pal::prose_ls(unlist(d2$values[1L]), last_sep = " oder ", wrap = '"'),
                   " geantwortet werden.")[is_question_block_compact],
            ""[is_question_block],
            notice_mandatory[is_question_block && d2$is_mandatory[1L]],
            notice_multiple_answers[is_question_block && d2$allow_multiple_answers[1L]])
        }) %>%
        purrr::list_c(ptype = character())
      
      pretty_group <-
        k1$group %>%
        stringr::str_replace_all("_", " ") %>%
        stringr::str_to_title() %>%
        emph_md(emph = "**")
      
      c(paste0("## Block ", pretty_group),
        "",
        question_blocks,
        "",
        "{{< pagebreak >}}",
        "")
    }) %>%
    purrr::list_c(ptype = character())
  
  c(paste0("# ", survey_config$title[[lang]]),
    "",
    survey_config$intro[[lang]],
    "",
    "{{< pagebreak >}}",
    "",
    survey_blocks,
    survey_config$outro[[lang]]) %>%
    brio::write_lines(path = path)
}

#' Convert question values to codes
#'
#' Converts character question values to their integer code counterparts. The latter are useful mainly because they're language-independent.
#'
#' @param var Variable holding the question values. A character vector with an `id` and a `lang` attribute.
#' @param qstnr TODO
#'
#' @return An integer vector of the same length as `var`.
#' @export
as_int_vals <- function(var,
                        qstnr = pal::pkg_config_val(key = "cur_qstnr",
                                                    pkg = this_pkg)) {
  var_id <- attr(x = var,
                 which = "id",
                 exact = TRUE)
  
  var_lang <- attr(x = var,
                   which = "lang",
                   exact = TRUE)
  
  purrr::walk(c(var_id,
                var_lang),
              ~ if (is.null(.x)) {
                cli::cli_abort("{.arg var} has no {.var .x} attribute set.")
              })
  
  val_name <- glue::glue("value.{var_lang}")
  lookup <- qstnr %>% dplyr::filter(id == !!var_id & !!as.symbol(val_name) %in% var)
  checkmate::assert_subset(var,
                           choices = lookup[[val_name]])
  
  result <- lookup$value.int[match(var, lookup[[val_name]])]
  attr(result, "id") <- var_id
  result
}

#' Get common value scale
#'
#' Determines the greatest common [values scale](https://en.wikipedia.org/wiki/Level_of_measurement) between two value scales `x` and `y` in the hierarchy
#' `r setdiff(value_scales_strict, "ordinal_descending") %>% stringr::str_remove("(?<=^ordinal).+") %>% pal::wrap_chr("*") %>% paste0(collapse = " < ")`.
#'
#' Note that
#' - the value scales *interval* and *ratio* are assumed to always be in **ascending** order.
#' - the value scale *none* is treated specially in the sense that it is ignored when finding the common value scale between *none* and any other value scale.
#'
#' @param x First value scale.
#' @param y Second value scale.
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' qstnr::common_val_scale("interval", "nominal")
#' qstnr::common_val_scale("interval", "ratio")
#' qstnr::common_val_scale("ordinal_ascending", "ordinal_descending")
#' 
#' try(
#'   qstnr::common_val_scale("ordinal_descending", "ratio")
#' )
common_val_scale <- function(x,
                             y) {
  rlang::arg_match0(arg = x,
                    values = value_scales)
  rlang::arg_match0(arg = y,
                    values = value_scales)
  
  if ("ordinal_descending" %in% c(x, y) && any(c("interval", "ratio") %in% c(x, y))) {
    cli::cli_abort("Incompatible value scales {.val {y}} and {.val y} provided.")
    
  } else if (x == "none" && y == "none") {
    return("none")
    
  } else if (all(c("ordinal_ascending", "ordinal_descending") %in% c(x, y))) {
    return("nominal")
    
  } else {
    return(intersect(value_scales_strict, c(x,y))[1L])
  }
}

#' Get value set
#'
#' Returns the value set identified by the provided `id`. The prefix `"desc:"` can be used to reverse the order of the set's values.
#'
#' @inheritParams gen_qstnr
#' @param id String that uniquely identifies the value set.
#'
#' @return A list.
#' @export
val_set <- function(id,
                    survey_config = survey_config) {
  
  is_desc <- startsWith(id, "desc:")
  id %<>% stringr::str_remove("^desc:")
  rlang::arg_match0(arg = id,
                    values = names(survey_config$value_sets))
  
  result <- survey_config$value_sets[[id]]
  
  if (is_desc) {
    result$values %<>% purrr::modify_tree(leaf = rev,
                                          is_node = is.list)
  }
  
  result
}

val_ptype <- function(type,
                      size = NULL) {
  # TODO
}

vals <- function(id,
                 survey_config = survey_config) {
  
}
