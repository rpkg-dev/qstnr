# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/qstnr.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literate programming approach used applying the R Markdown format.

# qstnr: Helps Creating and Maintaining Survey Questionnaires
# Copyright (C) 2023 Salim Br√ºggemann
# 
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

utils::globalVariables(names = c(".",
                                 ":=",
                                 # tidyselect fns
                                 "all_of",
                                 "any_of",
                                 "matches",
                                 "starts_with",
                                 # other
                                 "description",
                                 "group_id",
                                 "id",
                                 "int",
                                 "init_config",
                                 "lang",
                                 "name",
                                 "path",
                                 "question",
                                 "question_block",
                                 "question_block_filled",
                                 "targets",
                                 "title",
                                 "value_order",
                                 "value_scale",
                                 "value_set_id",
                                 "value_sets",
                                 "values",
                                 "values_targets"))

.onLoad <- function(libname, pkgname) {
  
  # clear pkgpins cache
  tryCatch(expr = pkgpins::clear_cache(board = pkgpins::board(pkg = pkgname,
                                                              pkg_versioned = FALSE),
                                       max_age = pal::pkg_config_val(key = "global_max_cache_age",
                                                                     pkg = pkgname)),
           error = function(e) cli::cli_alert_warning(text = "Failed to clear pkgpins cache on load of {.pkg {pkgname}}. Error message: {e$message}"))
}

this_pkg <- utils::packageName()

all_spec_parts <- c("links",
                    "footnotes",
                    "value_sets",
                    "targets",
                    "question_blocks",
                    "items")

struct_source <- list("[[{.strong source}]]" = list("{.strong list},{.strong file},{.strong url} = {.emph EXPR},{.emph PATH},{.emph URL}"))

struct_survey <- list("{.strong qstnr}" = list(
  "{.strong items}" = c(struct_source,
                        list("[[{.strong group}]]" = list("id = {.strong {'<questionnaire_block>'}}",
                                                          "item_ids = [ {.emph id_1}, {.emph id_2}, {.emph ...} ]"))),
  "{.strong question_blocks}" = struct_source,
  "{.strong value_sets}" = struct_source,
  "{.strong targets}" = struct_source,
  "{.strong footnotes}" = struct_source,
  "{.strong links}" = struct_source
))

rm(struct_source)

assert_qstnr_tibble <- function(qstnr,
                                cols = character()) {
  
  checkmate::assert_data_frame(qstnr,
                               all.missing = FALSE,
                               min.rows = 1L)
  missing_cols <- setdiff(cols,
                          colnames(qstnr))
  if (length(missing_cols) > 0L) {
    cli::cli_abort("Mandatory columns {.var {missing_cols}} are missing from {.arg qstnr}.")
  }
}

assert_survey_config <- function(survey_config,
                                 els = character()) {
  
  checkmate::assert_list(survey_config,
                         all.missing = FALSE)
  missing_els <- setdiff(els,
                         names(survey_config))
  if (length(missing_els) > 0L) {
    cli::cli_abort("Mandatory elements {.var {missing_els}} are missing from {.arg survey_config}.")
  }
}

combine_spec_part_srcs <- function(srcs,
                                   spec_part,
                                   dir,
                                   validate) {
  result <- list()
  
  for (i in seq_along(srcs)) {
    
    src_type <- names(srcs[[i]])
    src_content <- switch(EXPR = src_type,
                          "expr" = spec_part_expr(expr = srcs[[i]]$expr),
                          "file" = spec_part_file(file = srcs[[i]]$file,
                                                  dir = dir,
                                                  spec_part = spec_part,
                                                  validate = validate),
                          "url"  = spec_part_url(url = srcs[[i]]$url,
                                                 spec_part = spec_part,
                                                 validate = validate))
    result %<>% purrr::list_modify(!!!src_content)
  }
  
  result
}

emph_md <- function(x,
                    emph = "*") {
  
  x %>%
    purrr::map_chr(\(x) {
      
      x %>%
        stringr::str_split(pattern = "\n") %>%
        purrr::map(\(x2) {
          x2 %>%
            stringr::str_replace_all(pattern = paste0(stringr::str_escape(emph), "(.*)", stringr::str_escape(emph)),
                                     replacement = "\\1") %>%
            stringr::str_replace_all(pattern = "^(.)",
                                     replacement = paste0(emph, "\\1")) %>%
            stringr::str_replace_all(pattern = "(.)$",
                                     replacement = paste0("\\1", emph))
        }) %>%
        purrr::list_c(ptype = character()) %>%
        stringr::str_flatten(collapse = "\n")
    })
}

gen_qstnr_row <- function(.item,
                          ...) {
  
  result <- tibble::tibble(.rows = 1L)
  
  for (key in setdiff(item_keys$key, "i")) {
    
    val <- .item[[key]]
    is_list_col <- !item_keys$is_scalar[item_keys$key == key] || item_keys$has_lang_subkeys[item_keys$key == key]
    
    if (is.null(val)) {
      
      # assign explicit default val if present
      if (item_keys$has_default[item_keys$key == key]) {
        val <- unlist(item_keys$default_val[item_keys$key == key],
                      recursive = FALSE)
        
        # assign NA of proper type if non-list col
      } else if (!is_list_col) {
        val <- unlist(item_keys$default_val[item_keys$key == key],
                      recursive = FALSE)[NA]
      }
      # perform possible string interpolation
    } else if (item_keys$type[item_keys$key == key] == "character") {
      
      val %<>% purrr::modify_tree(leaf = \(x1) purrr::map_chr(x1, \(x2) interpolate(x2, ...)),
                                  is_node = is.list)
    }
    
    if (is_list_col) {
      val %<>% list()
    }
    
    result %<>% tibble::add_column(!!key := val)
  }
  
  result
}

gen_qstnr_rows <- function(item,
                           i = 1L,
                           i_list = list()) {
  
  if (i < length(item$i)) {
    
    result <-
      purrr::map(item$i[[i]],
                 \(cur_i) {
                   
                   i_list %<>% c(rlang::list2("i{i}" := cur_i))
                   
                   gen_qstnr_rows(item = item,
                                  i = i + 1L,
                                  i_list = i_list)
                 }) %>%
      purrr::list_rbind()
    
  } else {
    
    result <-
      purrr::map(item$i[[i]],
                 \(cur_i) {
                   
                   i_list %<>% c(rlang::list2("i{i}" := cur_i))
                   
                   gen_qstnr_row(.item = item,
                                 !!!i_list)
                   
                 }) %>%
      purrr::list_rbind()
  }
  
  result
}

interpolate <- function(.x,
                        ...) {

  # assign objects in dots to current env ensuring `cli::pluralize()` finds them
  rlang::env_bind(.env = rlang::current_env(),
                  ...)
  
  cli::pluralize(.x,
                 .null = NA_character_,
                 .trim = FALSE)
}

order_qstnr_cols <- function(qstnr) {
  
  qstnr %>% dplyr::relocate(any_of(qstnr_cols))
}

rm_p <- function(x) {
  
  stringr::str_replace(string = x,
                       pattern = "^<p>(.*)</p>(\n)?$",
                       replacement = "\\1")
}

schema_url <- function(spec_part,
                       dev = TRUE) {
  
  glue::glue("https://qstnr.rpkg.dev/", ifelse(dev, "dev/", ""), "schemas/qstnr-{spec_part}.schema.json")
}

spec_part_expr <- function(expr) {
  
  eval(expr = parse(text = expr),
       # eval in empty env to avoid unintended results
       envir = emptyenv()) %>%
    checkmate::assert_list(any.missing = FALSE)
}

spec_part_file <- function(file,
                           dir,
                           spec_part,
                           validate) {
  
  path <- fs::path(dir, file)
  
  if (is.null(validate) || validate) {
    toml_validate(input = path,
                  from_file = TRUE,
                  spec_part = spec_part,
                  use_cache = is.null(validate))
  }
  
  pal::toml_read(input = path,
                 from_file = TRUE)
}

spec_part_url <- function(url,
                          spec_part,
                          validate) {
  toml_content <-
    httr::RETRY(verb = "GET",
              url = url) %>%
    httr::content(as = "text", encoding = "UTF-8")
  
  if (is.null(validate) || validate) {
    toml_validate(input = toml_content,
                  from_file = FALSE,
                  spec_part = spec_part,
                  use_cache = is.null(validate))
  }
  
  pal::toml_read(input = toml_content,
                 from_file = FALSE)
}

toml_validate <- function(input,
                          from_file,
                          spec_part,
                          use_cache = TRUE) {
  
  hash <- if (from_file) rlang::hash_file(path = input) else rlang::hash(input)
  
  # cache validation based on TOML (file) content hash
  pkgpins::with_cache(expr = pal::toml_validate(input = input,
                                                from_file = from_file,
                                                schema = schema_url(spec_part = spec_part)),
                      pkg = this_pkg,
                      from_fn = "toml_validate",
                      from_file,
                      hash,
                      pkg_versioned = FALSE,
                      use_cache = use_cache,
                      max_cache_age = Inf)
}

#' Read in survey config
#'
#' Assembles a raw TOML survey configuration into a combined survey configuration list.
#'
#' @param path Path to the survey config TOML file. A character scalar.
#' @param validate Whether or not to validate all input TOML files, i.e. ensure that they adhere to their respective schemas. Validation usually adds a
#'   noticeable delay. If `NULL`, validation is performed only for files whose content has changed since the last successful validation.
#'
#' @return A list containing the combined survey configuration.
#' @family survey_prep
#' @export
read_survey_config <- function(path,
                               validate = NULL) {
  
  checkmate::assert_flag(validate,
                         null.ok = TRUE)
  
  if (is.null(validate) || validate) {
    toml_validate(input = path,
                  from_file = TRUE,
                  spec_part = "survey",
                  use_cache = is.null(validate))
  }
  
  dir <- fs::path_dir(path) %>% fs::path_abs()
  survey_config_raw <- pal::toml_read(input = path)
  spec_parts <-
    names(survey_config_raw$qstnr) %>%
    intersect(all_spec_parts) %>%
    pal::order_by(by = all_spec_parts) %>%
    rlang::set_names() %>%
    purrr::map(~ {
      combine_spec_part_srcs(srcs = survey_config_raw$qstnr[[.x]]$source,
                             spec_part = .x,
                             dir = dir,
                             validate = validate)
    })
  # validity check: ensure no value set has the reserved name/ID `values`
  if (any(names(spec_parts$value_sets) == "values")) {
    
    cli::cli_abort("Value set with reserved name {.val values} detected in value set specification.")
  }
  if (spec_parts$value_sets |>
      purrr::map_chr(\(x) purrr::chuck(x, "id")) |> 
      magrittr::equals("values") |>
      any()) {
    
    cli::cli_abort("Value set with reserved {.var id} {.val values} detected in value set specification.")
  }
  # keep only items that are actually needed
  spec_parts$items %<>% purrr::keep_at(at = unlist(purrr::map_depth(.x = survey_config_raw$qstnr$items$group,
                                                                    .depth = 1L,
                                                                    .f = \(x) x$item_ids)))
  # extract non-spec-part stuff
  other <- survey_config_raw$qstnr %>% purrr::keep_at(at = setdiff(survey_config_keys,
                                                                   all_spec_parts))
  # create final list struct
  rlang::list2(item_groups = survey_config_raw$qstnr$items$group,
               !!!spec_parts,
               !!!other)
}

#' Convert survey config from Markdown to HTML
#'
#' Recursively converts the keys at the specified pluck locations of a survey configuration from Markdown to HTML using [commonmark::markdown_html()]. Keys to
#' be converted must be of (nested) type character.
#'
#' @inheritParams gen_qstnr
#' @inheritParams htmlize_qstnr
#' @param ... [Pluck][purrr::pluck] locations to convert to HTML. All (sub)keys targeted here must be of type character.
#'   `r pkgsnip::param_lbl("dyn_dots_support")`
#' @param rm_p Whether or not to omit the outer `<p>` tag when converting values to HTML.
#'
#' @return `survey_config` with the specified keys recursively converted to HTML text.
#' @family survey_prep
#' @export
htmlize_survey_config <- function(survey_config,
                                  ...,
                                  rm_p = FALSE,
                                  hard_line_breaks = FALSE,
                                  smart_punctuation = TRUE,
                                  strip_footnotes = TRUE,
                                  normalize = TRUE,
                                  extensions = c("table", "strikethrough", "tasklist")) {
  
  assert_survey_config(survey_config = survey_config)
  checkmate::assert_flag(strip_footnotes)
  
  for (pl in rlang::list2(...)) {
    
    survey_config %<>% purrr::modify_in(.where = pl,
                                        .f = \(x) purrr::modify_tree(x,
                                                                     is_node = is.list,
                                                                     leaf = \(x2) {
                                                                       
                                                                       if (length(x2) > 0L) {
                                                                         
                                                                         if (!checkmate::test_character(x2)) {
                                                                           cli::cli_abort(paste0("Key {.var {key}} at pluck location {.code {deparse(pl)}} is ",
                                                                                                 "not of (nested) type character."))
                                                                         }
                                                                         
                                                                         if (strip_footnotes) {
                                                                           x2 %<>% pal::strip_md_footnotes()
                                                                         }
                                                                         
                                                                         x2 %<>% purrr::map_chr(\(x3) commonmark::markdown_html(text = x3,
                                                                                                                                hardbreaks = hard_line_breaks,
                                                                                                                                smart = smart_punctuation,
                                                                                                                                normalize = normalize,
                                                                                                                                footnotes = !strip_footnotes,
                                                                                                                                extensions = extensions))
                                                                         if (rm_p) x2 %<>% rm_p()
                                                                       }
                                                                       
                                                                       x2
                                                                     }))
  }
  
  survey_config
}

#' Generate questionnaire tibble
#'
#' @param survey_config Survey configuration list as returned by [read_survey_config()].
#'
#' @return `r pkgsnip::return_label("data")`
#' @family qstnr_gen
#' @export
gen_qstnr <- function(survey_config) {
  
  assert_survey_config(survey_config = survey_config,
                       els = c("items", "item_groups"))
  result <-
    survey_config$item_groups %>%
    rlang::set_names(nm = purrr::map_depth(., 1L, \(x) x$id)) %>%
    # for each item group
    purrr::map(
      # for each item ID
      \(group) {
        purrr::map(
          group$item_ids,
          \(id) {
            
            item <- survey_config$items[[id]]
            
            # integrity check
            if (is.null(item)) {
              cli::cli_abort("Item with {.var id} {.val {id}} is listed in survey configuration but missing from survey items specifications.")
            }
            
            if (length(item[["i"]]) > 0L) {
              return(gen_qstnr_rows(item = item))
            } else {
              return(gen_qstnr_row(.item = item))
            }
          }) %>%
          purrr::list_rbind()
      }) %>%
    purrr::list_rbind(names_to = "group_id") %>%
    # add overall item numbering
    tibble::rowid_to_column(var = "order") %>%
    # replace `value_sets` with actual `values` and add complemented value sets as `values` subkey `value_set_id`
    dplyr::group_by(id) %>%
    dplyr::group_modify(\(d, k) {
      
      # combine all (int and ext) value sets
      d_new <-
        unlist(d$value_sets) |>
        purrr::map(\(value_set_id) {
          
          # handle internal value set
          if (value_set_id == "values") {
            
            result <-
              d$values |>
              dplyr::first() |>
              tibble::as_tibble() |>
              tibble::add_column(value_set_id = "values",
                                 value_scale = d$value_scale) |>
              dplyr::mutate(int = as.integer(int))
            
            # handle external value sets
          } else {
            
            val_set <- val_set(id = value_set_id,
                               survey_config = survey_config)
            result <-
              val_set$values |>
              tibble::as_tibble() |>
              tibble::add_column(value_set_id = value_set_id,
                                 value_scale = val_set$value_scale)
          }
          
          result
        }) |>
        purrr::list_rbind()
      
      # complement with default `values.targets`
      if (!("targets" %in% colnames(d_new))) {
        d_new$targets <- "all"
      }
      
      # add common value scale to top level
      d$value_scale <- purrr::reduce(unique(d_new$value_scale),
                                     common_val_scale)
      # harmonize col order and wrap whole tibble in list
      d_new %<>%
        dplyr::relocate(colnames(.) |> stringr::str_subset("^\\w{2}$") |> sort(),
                        int, targets, value_scale, value_set_id) %>%
        list()
      
      d$values <- d_new
      d
    }) |>
    dplyr::ungroup() |>
    dplyr::select(-value_sets) |>
    # reduce to English `title` and `description` only for now
    dplyr::mutate(title = purrr::map_chr(title, \(x) x$en),
                  description = purrr::map_chr(description, \(x) x$en)) |>
    # restore original item order
    dplyr::arrange(order) |>
    # harmonize col order
    order_qstnr_cols()
  
  # warn if item and item group IDs overlap
  ids_overlap <- intersect(result$group_id,
                           result$id)
  
  if (length(ids_overlap) > 0L) {
    cli::cli_warn("Item group identifiers and item identifiers must be overall unique for further processing. Overlapping IDs include {.val {ids_overlap}}.")
  }
  
  result
}

#' Unnest questionnaire tibble
#'
#' Unnests a nested qstnr tibble as returned by [gen_qstnr()] into one row per question `lang` and `id`.
#'
#' @param qstnr Nested questionnaire tibble as returned by [gen_qstnr()].
#'
#' @return `r pkgsnip::return_label("data")`
#' @family qstnr_gen
#' @export
unnest_qstnr <- function(qstnr) {
  
  assert_qstnr_tibble(qstnr = qstnr,
                      cols = c("order", "id", "question_block", "question", "values"))
  qstnr %>%
    dplyr::group_by(id) %>%
    dplyr::group_modify(\(d, k) {
      
      lang_specific_subset <-
        d %>%
        dplyr::select(question) %>%
        # unnest `question` lang-subkeys
        tidyr::unnest_longer(col = question,
                             indices_to = "lang",
                             keep_empty = TRUE,
                             simplify = FALSE)
      
      d$values_int <- list(d$values[[1L]]$int)
      d$values_targets <- list(d$values[[1L]]$targets)
      d$values_scale <- list(d$values[[1L]]$value_scale)
      d$values_set_id <- list(d$values[[1L]]$value_set_id)
      d$values <- list(d$values[[1L]] %>% purrr::keep_at(at = nchar(names(.)) == 2L))
      
      lang_specific_subset_2 <-
        d$values |>
        dplyr::first() |>
        purrr::imap(\(col, lang) tibble::tibble(lang = lang,
                                                values = list(col))) |>
        purrr::list_rbind()
      
      # NOTE: items can have no `values` and thus `lang_specific_subset_2` no rows
      if (nrow(lang_specific_subset_2)) {
        
        lang_specific_subset %<>% dplyr::full_join(y = lang_specific_subset_2,
                                                   by = "lang")
      }
        
      d %>%
        dplyr::select(-c(question, values)) %>%
        dplyr::cross_join(y = lang_specific_subset)
    }) %>%
    dplyr::ungroup() %>%
    # restore row order
    dplyr::arrange(order) %>%
    # harmonize col order
    order_qstnr_cols()
}

#' Unnest questionnaire tibble's item values
#'
#' @description
#' Unnests a semi-unnested qstnr tibble as returned by [unnest_qstnr()] into one row per question `lang`, `id` and `value`.
#' 
#' The columns `r val_cols <- qstnr_cols |> stringr::str_subset("^values"); val_cols |> pal::prose_ls(wrap = "\x60")` will thereby become
#' `r val_cols |> stringr::str_replace("^values", "value") |> pal::prose_ls(wrap = "\x60")`. Additionally, a column `value_order` is added holding the intended
#' value order as defined in the questionnaire.
#'
#' @param qstnr Semi-unnested questionnaire tibble as returned by [unnest_qstnr()].
#'
#' @return `r pkgsnip::return_label("data")`
#' @family qstnr_gen
#' @export
unnest_qstnr_vals <- function(qstnr) {
  
  assert_qstnr_tibble(qstnr = qstnr,
                      cols = c("order", "lang", "id", "values", "values_int"))
  qstnr |>
    # complement `values` with `values_int`
    dplyr::group_by(id, lang) |>
    dplyr::group_modify(\(d, k) {
      
      if (is.null(d$values[[1L]])) {
        d$values <- purrr::map(d$values_int,
                               \(x) as.character(x))
      }
      
      d
    }) |>
    dplyr::ungroup() |>
    # harmonize `values_targets` struct
    dplyr::mutate(dplyr::across(any_of("values_targets"),
                                \(x) purrr::map(x,
                                                \(x2) {
                                                if (purrr::pluck_depth(x2) < 2L) {
                                                  x2 %<>% as.list()
                                                }
                                                x2
                                              }))) |>
    # unnest `values*` cols
    tidyr::unnest_longer(col = starts_with("values"),
                         indices_to = "{col}_order") |>
    ## remove top-level `value_scale` col in favor of per-value `values_scale`
    dplyr::select(-any_of("value_scale")) |>
    dplyr::rename_with(.cols = starts_with("values"),
                       .fn = \(x) stringr::str_replace(string = x,
                                                       pattern = "^values",
                                                       replacement = "value")) |>
    # remove surplus `value_*_order` cols
    dplyr::select(-matches("^value_.+_order$")) |>
    # unnest `question` col if present
    tidyr::unnest_longer(col = any_of("question"),
                         keep_empty = TRUE) |>
    # restore row order
    dplyr::arrange(order,
                   lang,
                   value_order) |>
    # harmonize col order
    order_qstnr_cols()
}

#' Convert qstnr columns from Markdown to HTML
#'
#' Recursively converts the specified columns from Markdown to HTML using [commonmark::markdown_html()]. Columns to be converted must be of (nested) type
#' character.
#'
#' @inheritParams unnest_qstnr_vals
#' @inheritParams commonmark::markdown_html
#' @param cols Column names to convert to HTML. All columns must be of type character. Mustn't overlap with `cols_rm_p`.
#'   `r pkgsnip::param_lbl("tidy_select_support")`
#' @param cols_rm_p Columns names to convert to HTML *without the outer `<p>` tag*. All columns must be of type character. Mustn't overlap with `cols`.
#'   `r pkgsnip::param_lbl("tidy_select_support")`
#' @param hard_line_breaks Whether or not to interpret all newlines within a paragraph as hard line breaks instead of spaces. This setting conforms to [Pandoc's
#'   `hard_line_breaks` extension](https://pandoc.org/MANUAL.html#extension-hard_line_breaks).
#' @param smart_punctuation Whether or not to enable smart punctation conforming to [Pandoc's `smart` extension](https://pandoc.org/MANUAL.html#extension-smart)
#'   which converts straight quotes to curly quotes, `---` to an em-dash (‚Äî), `--` to an en-dash (‚Äì), and `...` to ellipses (‚Ä¶). It also replaces regular spaces
#'   after certain abbreviations such as `Mr.` with [non-breaking spaces](https://en.wikipedia.org/wiki/Non-breaking_space).
#' @param strip_footnotes Whether or not to remove Markdown footnotes.
#'
#' @return `qstnr` with values in `cols` converted to HTML text.
#' @family qstnr_gen
#' @export
htmlize_qstnr <- function(qstnr,
                          cols = c("title", "description", "question"),
                          cols_rm_p = "values",
                          hard_line_breaks = FALSE,
                          smart_punctuation = TRUE,
                          strip_footnotes = TRUE,
                          normalize = TRUE,
                          extensions = c("table", "strikethrough", "tasklist")) {
  
  assert_qstnr_tibble(qstnr = qstnr)
  checkmate::assert_flag(strip_footnotes)
  
  # tidy selection
  defused_cols <- rlang::enquo(cols)
  defused_cols_rm_p <- rlang::enquo(cols_rm_p)
  ix_cols <- tidyselect::eval_select(expr = defused_cols,
                                     data = qstnr)
  ix_cols_rm_p <- tidyselect::eval_select(expr = defused_cols_rm_p,
                                          data = qstnr)
  names_cols <- names(ix_cols)
  names_cols_rm_p <- names(ix_cols_rm_p)
  overlaps <- intersect(names_cols, names_cols_rm_p)
  
  if (length(overlaps) > 0L) {
    cli::cli_abort("Overlapping column specifications between {.arg cols} and {.arg cols_rm_p} detected: {.val overlaps}")
  }
  
  qstnr |> dplyr::mutate(dplyr::across(.cols = all_of(c(names_cols, names_cols_rm_p)),
                                       .fns = \(x) {
                                         
                                         cur_col <- dplyr::cur_column()
                                         do_rm_p <- cur_col %in% names_cols_rm_p
                                         
                                         x %<>% purrr::modify_tree(is_node = is.list,
                                                                   leaf = \(x2) {
                                                                     
                                                                     if (length(x2) > 0L) {
                                                                       
                                                                       if (!checkmate::test_character(x2)) {
                                                                         cli::cli_abort(paste0("Column {.var {cur_col}} specified in {.arg {ifelse(do_rm_p, ",
                                                                                               "'cols_rm_p', 'cols')}} is not of (nested) type character."))
                                                                       }
                                                                       
                                                                       if (strip_footnotes) {
                                                                         x2 %<>% pal::strip_md_footnotes()
                                                                       }
                                                                       
                                                                       x2 %<>% purrr::map_chr(\(x3) commonmark::markdown_html(text = x3,
                                                                                                                              hardbreaks = hard_line_breaks,
                                                                                                                              smart = smart_punctuation,
                                                                                                                              normalize = normalize,
                                                                                                                              footnotes = !strip_footnotes,
                                                                                                                              extensions = extensions))
                                                                       if (do_rm_p) x2 %<>% rm_p()
                                                                     }
                                                                     
                                                                     x2
                                                                   })
                                       }))
}

#' Generate questionnaire docs
#'
#' Generates a [Quarto Markdown representation][gen_qmd_qstnr] of the input for each specified language, renders it to Microsoft Word (DOCX) format and
#' optionally uploads it as a Google Doc to the specified `g_drive_dir`.
#'
#' @inheritParams gen_qmd_qstnr
#' @param langs Languages in which to output the questionnaire. A subset of `survey_config$langs` or `NULL` for all languages present.
#' @param output_dir Directory to write the generated questionnaire files to. A character scalar.
#' @param keep_qmd Whether to keep or delete the intermediate generated Quarto Markdown files.
#' @param keep_docx Whether to keep or delete the intermediate generated Microsoft Word files.
#' @param create_g_docs Whether or not to turn the generated files into Google Docs placed under the Google Drive path `g_drive_dir`.
#' @param g_drive_dir Google Drive path under which to place the generated Google Docs. By default, the file is created in the current user's "My Drive" root
#'   folder. Ignored if `create_g_docs = FALSE`.
#' @param quiet `r pkgsnip::param_label("quiet")`
#'
#' @return `output_dir`, invisibly.
#' @family qstnr_gen
#' @export
gen_qstnr_docs <- function(qstnr,
                           survey_config,
                           langs = NULL,
                           add_item_ids = TRUE,
                           output_dir,
                           keep_qmd = TRUE,
                           keep_docx = FALSE,
                           create_g_docs = TRUE,
                           g_drive_dir = NULL,
                           quiet = FALSE) {
  
  assert_survey_config(survey_config = survey_config,
                       els = "langs")
  checkmate::assert_path_for_output(output_dir,
                                    overwrite = TRUE)
  checkmate::assert_flag(keep_qmd)
  checkmate::assert_flag(keep_docx)
  checkmate::assert_flag(create_g_docs)
  checkmate::assert_string(g_drive_dir,
                           null.ok = TRUE)
  checkmate::assert_flag(quiet)
  if (is.null(langs)) {
    langs <- survey_config$langs
  } else {
    rlang::arg_match0(arg = langs,
                      values = survey_config$langs)
  }
  
  # create output dir if necessary
  fs::dir_create(path = output_dir)
  
  if (!quiet) {
    status_msg <- "Generating {cli::qty(length(langs))}questionnaire{?s} in Quarto Markdown and DOCX formats..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"),
                           .auto_close = FALSE)
  }
  
  # generate questionnaire DOCX files intended for external translation/correction
  langs %>%
    purrr::walk(\(lang) {
      
      filename <- fs::path(output_dir, glue::glue("qstnr.{lang}.qmd"))
      
      gen_qmd_qstnr(qstnr = qstnr,
                    survey_config = survey_config,
                    lang = lang,
                    path = filename,
                    add_item_ids = add_item_ids)
      
      quarto::quarto_render(input = filename,
                            output_format = "docx",
                            execute = FALSE,
                            quiet = TRUE)
      if (!keep_qmd) {
        fs::file_delete(filename)
      }
    })
  
  if (!quiet) {
    cli::cli_progress_done()
  }
  
  if (create_g_docs) {
    
    if (!quiet) {
      status_msg <- "Uploading {length(langs)} DOCX questionnaire{?s} to Google Drive..."
      cli::cli_progress_step(msg = status_msg,
                             msg_done = paste(status_msg, "done"),
                             msg_failed = paste(status_msg, "failed"),
                             .auto_close = FALSE)
    }
    
    # upload questionnaire DOCX files to Google Drive (and convert to Google Docs)
    googledrive::drive_auth(path = pal::pkg_config_val(key = "gcp_key",
                                                       pkg = this_pkg))
    
    fs::path(output_dir, glue::glue("qstnr.{langs}.docx")) |>
      purrr::walk(\(f) {
        googledrive::drive_put(media = f,
                               path = g_drive_dir, 
                               name = fs::path_ext_remove(fs::path_file(f)),
                               type = "document")
      })
    
    if (!quiet) cli::cli_progress_done()
  }
  
  if (!keep_docx) {
    fs::path(output_dir, glue::glue("qstnr.{langs}.docx")) |> fs::file_delete()
  }
  
  invisible(output_dir)
}

#' Generate Quarto Markdown questionnaire
#'
#' Generates a [Quarto Markdown representation][gen_qmd_qstnr] of the input.
#'
#' @inheritParams gen_qstnr
#' @param qstnr Unnested questionnaire tibble as returned by [unnest_qstnr()].
#' @param lang Language in which to output the questionnaire. A character scalar.
#' @param path Path to write the generated questionnaire file to. A character scalar.
#' @param add_item_ids Whether or not to add questionnaire item identifiers next to the question texts.
#'
#' @return `qstnr`, invisibly.
#' @family qstnr_gen
#' @keywords internal
gen_qmd_qstnr <- function(qstnr,
                          survey_config,
                          lang,
                          path,
                          add_item_ids = TRUE) {
  
  assert_qstnr_tibble(qstnr = qstnr,
                      cols = c("lang", "group_id", "id", "question_block", "question", "values", "is_mandatory", "allow_multiple_answers"))
  assert_survey_config(survey_config = survey_config,
                       els = c("question_blocks", "title", "intro", "outro"))
  rlang::arg_match0(arg = lang,
                    values = unique(qstnr$lang))
  checkmate::assert_path_for_output(path,
                                    overwrite = TRUE)
  checkmate::assert_flag(add_item_ids)
  
  notice_mandatory <- c(pal::wrap_chr(survey_config$notice$mandatory[[lang]] %||%
                                        notice$mandatory[[lang]] %||%
                                        notice$mandatory$en,
                                      wrap = "*"),
                        "")
  notice_multiple_answers <- c(pal::wrap_chr(survey_config$notice$multiple_answers[[lang]] %||%
                                               notice$multiple_answers[[lang]] %||%
                                               notice$multiple_answers$en,
                                             wrap = "*"),
                               "")
  survey_blocks <-
    qstnr |>
    dplyr::filter(lang == !!lang) |>
    # fill missing `question_block`s with `id`s to avoid order mess up further below
    dplyr::mutate(question_block_filled = dplyr::if_else(is.na(question_block),
                                                         id,
                                                         question_block),
                  # note that we need to rely on factors to avoid alphabetical group key ordering further below
                  dplyr::across(c(group_id, question_block_filled, id),
                                \(x) factor(x,
                                            levels = unique(x)))) |>
    dplyr::group_by(group_id) |>
    dplyr::group_map(\(d1, k1) {
      
      question_blocks <-
        d1 |>
        dplyr::group_by(question_block_filled) |>
        dplyr::group_map(\(d2, k2) {
          
          is_question_block <- length(unique(d2$id)) > 1L
          is_question_block_compact <- is_question_block && length(unique(d2$values)) == 1L
          
          questions <-
            d2 |>
            dplyr::group_by(id) |>
            dplyr::group_map(\(d3, k3) {
              
              q_text <- emph_md(unlist(d3$question),
                                emph = "**")
              q_id <- paste0("^`", k3$id, "`^")
              
              # layout is conditional on whether the question is part of a block or not
              if (!is_question_block) {
                question <- c(paste0(q_text, "  "[add_item_ids]),
                              q_id[add_item_ids],
                              "",
                              paste0("- ", unlist(d3$values)),
                              "",
                              notice_mandatory[d3$is_mandatory],
                              notice_multiple_answers[d3$allow_multiple_answers])
              } else {
                question <- c(paste0("- ", q_text, " ", q_id[add_item_ids]))
                
                if (!is_question_block_compact) {
                  question %<>% c(paste0("  - ", unlist(d3$values)))
                }
              }
              
              question
            }) |>
            purrr::list_c(ptype = character())
          
          c(survey_config$question_blocks[[as.character(k2$question_block_filled)]]$intro[[lang]][is_question_block],
            ""[is_question_block],
            questions,
            ""[is_question_block_compact],
            paste0("Es kann jeweils mit ", pal::prose_ls(unlist(d2$values[1L]), last_sep = " oder ", wrap = '"'),
                   " geantwortet werden.")[is_question_block_compact],
            ""[is_question_block],
            notice_mandatory[is_question_block && d2$is_mandatory[1L]],
            notice_multiple_answers[is_question_block && d2$allow_multiple_answers[1L]])
        }) |>
        purrr::list_c(ptype = character())
      
      pretty_group <-
        k1$group_id |>
        stringr::str_replace_all("_", " ") |>
        stringr::str_to_title() |>
        emph_md(emph = "**")
      
      c(paste0("## Block ", pretty_group),
        "",
        question_blocks,
        "",
        "{{< pagebreak >}}",
        "")
    }) |>
    purrr::list_c(ptype = character())
  
  c(paste0("# ", survey_config$title[[lang]]),
    "",
    survey_config$intro[[lang]],
    "",
    "{{< pagebreak >}}",
    "",
    survey_blocks,
    survey_config$outro[[lang]]) |>
    brio::write_lines(path = path)
}

#' Convert question values to codes
#'
#' Converts character question values to their integer code counterparts. The latter are useful mainly because they're language-independent.
#'
#' @param var Variable holding the question values. A character vector with an `id` and a `lang` attribute.
#' @param qstnr TODO
#'
#' @return An integer vector of the same length as `var`.
#' @family aux
#' @export
as_int_vals <- function(var,
                        qstnr = pal::pkg_config_val(key = "cur_qstnr",
                                                    pkg = this_pkg)) {
  var_id <- attr(x = var,
                 which = "id",
                 exact = TRUE)
  
  var_lang <- attr(x = var,
                   which = "lang",
                   exact = TRUE)
  
  purrr::walk(c(var_id,
                var_lang),
              ~ if (is.null(.x)) {
                cli::cli_abort("{.arg var} has no {.var .x} attribute set.")
              })
  
  val_name <- glue::glue("value.{var_lang}")
  lookup <- qstnr %>% dplyr::filter(id == !!var_id & !!as.symbol(val_name) %in% var)
  checkmate::assert_subset(var,
                           choices = lookup[[val_name]])
  
  result <- lookup$value.int[match(var, lookup[[val_name]])]
  attr(result, "id") <- var_id
  result
}

#' Get common value scale
#'
#' Determines the greatest common [values scale](https://en.wikipedia.org/wiki/Level_of_measurement) between two value scales `x` and `y` in the hierarchy
#' `r setdiff(value_scales_strict, "ordinal_descending") %>% stringr::str_remove("(?<=^ordinal).+") %>% pal::wrap_chr("*") %>% paste0(collapse = " < ")`.
#'
#' Note that
#' - the value scales *interval* and *ratio* are assumed to always be in **ascending** order.
#' - the value scale *none* is treated specially in the sense that it is ignored when finding the common value scale between *none* and any other value scale.
#'
#' @param x First value scale.
#' @param y Second value scale.
#'
#' @return A character scalar.
#' @family aux
#' @export
#'
#' @examples
#' qstnr::common_val_scale("interval", "nominal")
#' qstnr::common_val_scale("interval", "ratio")
#' qstnr::common_val_scale("ordinal_ascending", "ordinal_descending")
#' 
#' try(
#'   qstnr::common_val_scale("ordinal_descending", "ratio")
#' )
common_val_scale <- function(x,
                             y) {
  rlang::arg_match0(arg = x,
                    values = value_scales)
  rlang::arg_match0(arg = y,
                    values = value_scales)
  
  if ("ordinal_descending" %in% c(x, y) && any(c("interval", "ratio") %in% c(x, y))) {
    cli::cli_abort("Incompatible value scales {.val {y}} and {.val y} provided.")
    
  } else if (x == "none" && y == "none") {
    return("none")
    
  } else if (all(c("ordinal_ascending", "ordinal_descending") %in% c(x, y))) {
    return("nominal")
    
  } else {
    return(intersect(value_scales_strict, c(x,y))[1L])
  }
}

#' Get survey group title
#'
#' Extracts the multilanguage group title list for the specified group from the given survey config.
#'
#' @inheritParams gen_qstnr
#' @param group_id Survey group identifier to retrieve the group title of. A character scalar.
#'
#' @return A list.
#' @family aux
#' @export
group_title <- function(survey_config,
                        group_id) {
  
  assert_survey_config(survey_config = survey_config,
                       els = c("item_groups"))
  
  checkmate::assert_choice(group_id,
                           choices = purrr::map_chr(survey_config$item_groups,
                                                    \(x) purrr::chuck(x, "id")))
  survey_config$item_groups |>
    purrr::map(\(x) if (purrr::chuck(x, "id") == group_id) purrr::pluck(x, "title") else NULL) |>
    purrr::compact()
}

#' Get value set
#'
#' Returns the value set identified by the provided `id`. The prefix `"desc:"` can be used to reverse the order of the set's values.
#'
#' @inheritParams gen_qstnr
#' @param id String that uniquely identifies the value set.
#'
#' @return A list.
#' @family aux
#' @export
val_set <- function(id,
                    survey_config = survey_config) {
  
  checkmate::assert_string(id)
  assert_survey_config(survey_config = survey_config,
                       els = "value_sets")
  
  is_desc <- startsWith(id, "desc:")
  id %<>% stringr::str_remove("^desc:")
  rlang::arg_match0(arg = id,
                    values = names(survey_config$value_sets))
  
  result <- survey_config$value_sets[[id]]
  
  if (is_desc) {
    result$values %<>% purrr::modify_tree(leaf = rev,
                                          is_node = is.list)
  }
  
  result
}

vals <- function(id,
                 survey_config = survey_config) {
  
}

#' `r this_pkg` package configuration metadata
#'
#' A [tibble][tibble::tbl_df] with metadata of all possible `r this_pkg` package configuration options. See [pal::pkg_config_val()] for more information.
#'
#' @format `r pkgsnip::return_label("data_cols", cols = colnames(pkg_config))`
#' @export
#'
#' @examples
#' qstnr::pkg_config
"pkg_config"
